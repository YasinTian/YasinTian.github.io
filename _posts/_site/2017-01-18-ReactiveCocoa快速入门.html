<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa地址</a></p>

<p>从RAC 5.0开始，RAC进行了巨大的变化，现在有了4个独立的库
<a href="https://github.com/ReactiveCocoa/ReactiveObjC">ReactiveObjC</a>
<a href="https://github.com/ReactiveCocoa/ReactiveSwift">ReactiveSwift</a>
<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>
<a href="https://github.com/ReactiveCocoa/ReactiveObjCBridge">ReactiveObjCBridge</a></p>

<h3 id="导入">导入</h3>

<p>用<code class="highlighter-rouge">cocoapods</code>导入</p>

<div class="highlighter-rouge"><pre class="highlight"><code>target 'ReactiveCocoa_Demo' do
  pod 'ReactiveCocoa'
end
</code></pre>
</div>

<p>导入头文件<code class="highlighter-rouge">#import &lt;ReactiveCocoa.h&gt;</code></p>

<h3 id="基本使用">基本使用</h3>
<p>我们先试试<code class="highlighter-rouge">UIButton</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>	[[btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
        NSLog(@"ddd");
    }];
</code></pre>
</div>
<p>点击button会打印”ddd”说明，调用了block里面的内容。
看着可能有点复杂，但是不熟的时候可以拆开写</p>

<p>先创建一个<code class="highlighter-rouge">RACSignal</code>对象，再添加要执行的block。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>	RACSignal *racSignal = [btn rac_signalForControlEvents:UIControlEventTouchUpInside];

	[racSignal subscribeNext:^(id x) {
        NSLog(@"ddd");
    }];
</code></pre>
</div>
<p><code class="highlighter-rouge">RACSignal</code>是RAC里面一个非常重要的概念，建议先掌握了<code class="highlighter-rouge">RACSignal</code>的基本用法后在去了解他的原理。</p>

<p>再来看看连续多个block的情况，比如已经创建了一个<code class="highlighter-rouge">UITextField</code>叫<code class="highlighter-rouge">tf</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>	RACSignal *tfRac = [tf rac_textSignal];

	[[tfRac filter:^BOOL(NSNumber*length) {
        return YES;
    }] subscribeNext:^(id x) {
        NSLog(@"%@", x);
    }];

</code></pre>
</div>

<p>这样当UITextField里面内容变化的时候就会打印出UITextField的内容。</p>

<h3 id="filter">filter</h3>

<p><code class="highlighter-rouge">filter</code>是一个过滤器里面能加一些判定条件用于判断是否继续往下面的执行。这样就表示当内容是123的时候才打印</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    [[tfRac filter:^BOOL(id value) {
        if([value isEqualToString:@"123"]){
            return YES;
        }
        return NO;
    }] subscribeNext:^(id x) {
        NSLog(@"%@",x);
    }];
</code></pre>
</div>

<h3 id="map">map</h3>

<p>还有一个常用的操作<code class="highlighter-rouge">map</code>，在<code class="highlighter-rouge">map</code>的<code class="highlighter-rouge">block</code>里面可以更改要往下传的数据，比如下面的例子，textfield的内容被传入<code class="highlighter-rouge">map</code>，在<code class="highlighter-rouge">block</code>里面计算了文字长度之后，把文字长度传了下去。后面的block收到的参数就是这个长度值了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	RACSignal *tfRac = [tf rac_textSignal];

    [[[tfRac
       map:^id(NSString*text){
           return @(text.length);
       }]
      filter:^BOOL(NSNumber*length){
          return[length integerValue] &gt; 3;
      }]
     subscribeNext:^(id x){
         NSLog(@"%@", x);
     }];
</code></pre>
</div>

<h3 id="rac宏">RAC宏</h3>
<p>在ReactiveCocoa有一个<code class="highlighter-rouge">RAC</code>宏非常好用,他可以直接把信号的输出应用到对象的属性上。参数1是要绑定的对象，参数2是要绑定的属性。下面的例子，当输入值为”123456”的时候背景颜色就会变成黄色了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    tf.backgroundColor = [UIColor redColor];
    RACSignal *tfRac = [tf rac_textSignal];
    RAC(tf,backgroundColor) = [tfRac map:^id(id value) {
        if([value isEqualToString:@"123456"]){
            return [UIColor yellowColor];
        }else{
            return [UIColor redColor];
        }
    }];
</code></pre>
</div>

<h3 id="信号聚合">信号聚合</h3>
<p>在用些时候需要聚合信号,<code class="highlighter-rouge">RACSignal</code>提供了<code class="highlighter-rouge">combineLatest:reduce:</code>这个方法可以把任意数量的信号聚合起来。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	//信号1
	RACSignal *tfRac = [tf rac_textSignal];
    [tfRac subscribeNext:^(id x) {
        NSLog(@"%@",x);
    }];
    
    //信号2
    RACSignal *tf1Rac = [tf1 rac_textSignal];
    [tf1Rac subscribeNext:^(id x) {
        NSLog(@"%@",x);
    }];
    
    //聚合信号
    [[RACSignal combineLatest:@[tfRac, tf1Rac]
                      reduce:^id(id x, id y){
                          
                          if([x isEqualToString:y]){
                              NSLog(@"一样");
                              return @1;
                          }else{
                              NSLog(@"不一样");
                              return @0;
                          }
                      }] subscribeNext:^(id x) {
                          NSLog(@"%@",x);
                      }];
</code></pre>
</div>

<p>###附加操作
有些时候我们可能需要在收到信号后进行一些附加操作，可以添加一个<code class="highlighter-rouge">doNext:</code>block。</p>
<div class="highlighter-rouge"><pre class="highlight"><code>	[[tfRac doNext:^(id x) {
        NSLog(@"附加操作");
    }] subscribeNext:^(id x) {
        
    }];
</code></pre>
</div>

<p>参考资料
<a href="http://www.cnblogs.com/tangchangjiang/p/5598079.html">ReactiveCocoa - 基础篇</a>
<a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1">ReactiveCocoa入门教程——第一部分</a>
<a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2">ReactiveCocoa入门教程——第二部分</a>
<a href="http://www.jianshu.com/p/87ef6720a096">最快让你上手ReactiveCocoa之基础篇</a>
<a href="http://www.jianshu.com/p/e10e5ca413b7">最快让你上手ReactiveCocoa之进阶篇</a></p>

